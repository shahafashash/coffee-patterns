{
	"Factory Pattern": {
		"scope": "python",
		"prefix": "!factory",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Product}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Product}' objects.",
			"    It declares the interface for the type of objects that the factory method creates.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract ${2:operation} method. Needs to be implemented by concrete '${1:Product}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:ConcreteProductA}(${1:Product}):",
			"    \"\"\"",
			"    Concrete product class that implements the '${1:Product}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:ConcreteProductB}(${1:Product}):",
			"    \"\"\"",
			"    Another concrete product class that implements the '${1:Product}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${5:Creator}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${5:Creator}' objects.",
			"    It declares the factory method that is supposed to return an object of type '${1:Product}'.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${6:factory_method}(self) -> ${1:Product}:",
			"        \"\"\"",
			"        Abstract ${6:factory_method} method. Needs to be implemented by concrete '${5:Creator}' objects.",
			"        ",
			"        Returns:",
			"            ${1:Product}: An object of type '${1:Product}'.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteCreatorA}(${5:Creator}):",
			"    \"\"\"",
			"    Concrete creator class that implements the '${5:Creator}' interface.",
			"    It overrides the factory method to create a '${3:ConcreteProductA}' instance.",
			"    \"\"\"",
			"    def ${6:factory_method}(self) -> ${3:ConcreteProductA}:",
			"        \"\"\"",
			"        Overrides the factory method to create a '${3:ConcreteProductA}' instance.",
			"        ",
			"        Returns:",
			"            ${3:ConcreteProductA}: An object of type '${3:ConcreteProductA}'.",
			"        \"\"\"",
			"        return ${3:ConcreteProductA}()",
			"",
			"class ${8:ConcreteCreatorB}(${5:Creator}):",
			"    \"\"\"",
			"    Another concrete creator class that implements the '${5:Creator}' interface.",
			"    It overrides the factory method to create a '${4:ConcreteProductB}' instance.",
			"    \"\"\"",
			"    def ${6:factory_method}(self) -> ${4:ConcreteProductB}:",
			"        \"\"\"",
			"        Overrides the factory method to create a '${4:ConcreteProductB}' instance.",
			"        ",
			"        Returns:",
			"            ${4:ConcreteProductB}: An object of type '${4:ConcreteProductB}'.",
			"        \"\"\"",
			"        return ${4:ConcreteProductB}()",
			""
		],
		"description": "Implements the Factory design pattern in Python.\nDefines:\n- An abstract class for products.\n- Concrete product classes that implement the interface.\n- An abstract creator class with a factory method.\n- Concrete creator classes that override the factory method to create specific product instances.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Product\nclass Coffee(ABC):\n    @abstractmethod\n    def brew(self) -> None:\n        pass\n\n# ConcreteProduct\nclass Espresso(Coffee):\n    def brew(self) -> None:\n        print(\"Brewing Espresso\")\n\n# ConcreteProduct\nclass Latte(Coffee):\n    def brew(self) -> None:\n        print(\"Brewing Latte\")\n\n# Creator\nclass CoffeeMachine(ABC):\n    @abstractmethod\n    def create_coffee(self) -> Coffee:\n        pass\n\n# ConcreteCreator\nclass EspressoMachine(CoffeeMachine):\n    def create_coffee(self) -> Espresso:\n        return Espresso()\n\n# ConcreteCreator\nclass LatteMachine(CoffeeMachine):\n    def create_coffee(self) -> Latte:\n        return Latte()\n\n# Client\ndef main() -> None:\n    espresso_machine = EspressoMachine()\n    latte_machine = LatteMachine()\n\n    espresso_machine.create_coffee().brew()\n    latte_machine.create_coffee().brew()\n\nif __name__ == \"__main__\":\n    main()"
	},

	"Abstract Factory": {
		"scope": "python",
		"prefix": "!abstract_factory",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:AbstractProductA}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:AbstractProductA}' objects.",
			"    It declares the interface for the type of objects that the factory method creates.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${2:operation}' method. Needs to be implemented by concrete '${1:AbstractProductA}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:ConcreteProductA1}(${1:AbstractProductA}):",
			"    \"\"\"",
			"    Concrete product class that implements the '${1:AbstractProductA}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:ConcreteProductA2}(${1:AbstractProductA}):",
			"    \"\"\"",
			"    Another concrete product class that implements the '${1:AbstractProductA}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${5:AbstractProductB}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${5:AbstractProductB}' objects.",
			"    It declares the interface for the type of objects that the factory method creates.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${6:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${6:operation}' method. Needs to be implemented by concrete '${5:AbstractProductB}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteProductB1}(${5:AbstractProductB}):",
			"    \"\"\"",
			"    Concrete product class that implements the '${5:AbstractProductB}' interface.",
			"    \"\"\"",
			"    def ${6:operation}(self) -> None:",
			"        pass",
			"",
			"class ${8:ConcreteProductB2}(${5:AbstractProductB}):",
			"    \"\"\"",
			"    Another concrete product class that implements the '${5:AbstractProductB}' interface.",
			"    \"\"\"",
			"    def ${6:operation}(self) -> None:",
			"        pass",
			"",
			"class ${9:AbstractFactory}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:AbstractProductA}' and '${5:AbstractProductB}' objects.",
			"    It declares the factory method that is supposed to return an object of type '${1:AbstractProductA}' or '${5:AbstractProductB}'.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${10:factory_method_a}(self) -> ${1:AbstractProductA}:",
			"        \"\"\"",
			"        Abstract factory method for creating '${1:AbstractProductA}' objects.",
			"        ",
			"        Returns:",
			"            ${1:AbstractProductA}: An object of type '${1:AbstractProductA}'.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${11:factory_method_b}(self) -> ${5:AbstractProductB}:",
			"        \"\"\"",
			"        Abstract factory method for creating '${5:AbstractProductB}' objects.",
			"        ",
			"        Returns:",
			"            ${5:AbstractProductB}: An object of type '${5:AbstractProductB}'.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${12:ConcreteFactory1}(${9:AbstractFactory}):",
			"    \"\"\"",
			"    Concrete factory class that implements the '${9:AbstractFactory}' interface.",
			"    It overrides the factory methods to create '${3:ConcreteProductA1}' and '${7:ConcreteProductB1}' instances.",
			"    \"\"\"",
			"    def ${10:factory_method_a}(self) -> ${3:ConcreteProductA1}:",
			"        \"\"\"",
			"        Overrides the factory method to create a '${3:ConcreteProductA1}' instance.",
			"        ",
			"        Returns:",
			"            ${3:ConcreteProductA1}: An object of type '${3:ConcreteProductA1}'.",
			"        \"\"\"",
			"        return ${3:ConcreteProductA1}()",
			"",
			"    def ${11:factory_method_b}(self) -> ${7:ConcreteProductB1}:",
			"        \"\"\"",
			"        Overrides the factory method to create a '${7:ConcreteProductB1}' instance.",
			"        ",
			"        Returns:",
			"            ${7:ConcreteProductB1}: An object of type '${7:ConcreteProductB1}'.",
			"        \"\"\"",
			"        return ${7:ConcreteProductB1}()",
			"",
			"class ${13:ConcreteFactory2}(${9:AbstractFactory}):",
			"    \"\"\"",
			"    Another concrete factory class that implements the '${9:AbstractFactory}' interface.",
			"    It overrides the factory methods to create '${4:ConcreteProductA2}' and '${8:ConcreteProductB2}' instances.",
			"    \"\"\"",
			"    def ${10:factory_method_a}(self) -> ${4:ConcreteProductA2}:",
			"        \"\"\"",
			"        Overrides the factory method to create a '${4:ConcreteProductA2}' instance.",
			"        ",
			"        Returns:",
			"            ${4:ConcreteProductA2}: An object of type '${4:ConcreteProductA2}'.",
			"        \"\"\"",
			"        return ${4:ConcreteProductA2}()",
			"",
			"    def ${11:factory_method_b}(self) -> ${8:ConcreteProductB2}:",
			"        \"\"\"",
			"        Overrides the factory method to create a '${8:ConcreteProductB2}' instance.",
			"        ",
			"        Returns:",
			"            ${8:ConcreteProductB2}: An object of type '${8:ConcreteProductB2}'.",
			"        \"\"\"",
			"        return ${8:ConcreteProductB2}()",
			""
		],
		"description": "Creates an Abstract Factory design pattern structure in Python.\nDefines:\n- Abstract product classes.\n- Concrete product classes.\n- An abstract factory class with factory methods for each product.\n- Concrete factory classes that override the factory methods to produce specific product instances.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# AbstractProductA\nclass CoffeeBean(ABC):\n    @abstractmethod\n    def grind(self) -> None:\n        pass\n\n# ConcreteProductA1\nclass ArabicaBean(CoffeeBean):\n    def grind(self) -> None:\n        print(\"Grinding Arabica Beans\")\n\n# ConcreteProductA2\nclass RobustaBean(CoffeeBean):\n    def grind(self) -> None:\n        print(\"Grinding Robusta Beans\")\n\n# AbstractProductB\nclass Milk(ABC):\n    @abstractmethod\n    def froth(self) -> None:\n        pass\n\n# ConcreteProductB1\nclass WholeMilk(Milk):\n    def froth(self) -> None:\n        print(\"Frothing Whole Milk\")\n\n# ConcreteProductB2\nclass AlmondMilk(Milk):\n    def froth(self) -> None:\n        print(\"Frothing Almond Milk\")\n\n# AbstractFactory\nclass CoffeeFactory(ABC):\n    @abstractmethod\n    def create_coffee_bean(self) -> CoffeeBean:\n        pass\n\n    @abstractmethod\n    def create_milk(self) -> Milk:\n        pass\n\n# ConcreteFactory1\nclass ArabicaLatteFactory(CoffeeFactory):\n    def create_coffee_bean(self) -> CoffeeBean:\n        return ArabicaBean()\n\n    def create_milk(self) -> Milk:\n        return WholeMilk()\n\n# ConcreteFactory2\nclass RobustaAlmondLatteFactory(CoffeeFactory):\n    def create_coffee_bean(self) -> CoffeeBean:\n        return RobustaBean()\n\n    def create_milk(self) -> Milk:\n        return AlmondMilk()\n\n# Client\ndef main() -> None:\n    arabica_latte_factory = ArabicaLatteFactory()\n    robusta_almond_latte_factory = RobustaAlmondLatteFactory()\n\n    arabica_latte_factory.create_coffee_bean().grind()\n    arabica_latte_factory.create_milk().froth()\n\n    robusta_almond_latte_factory.create_coffee_bean().grind()\n    robusta_almond_latte_factory.create_milk().froth()\n\nif __name__ == \"__main__\":\n    main()"
	},

	"Builder": {
		"scope": "python",
		"prefix": "!builder",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Product}:",
			"    \"\"\"",
			"    Represents the complex object under construction.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        \"\"\"",
			"        Defines the object to be built.",
			"        \"\"\"",
			"        pass",
			"",
			"    def add_${2:part1}(self) -> None:",
			"        pass",
			"",
			"    def add_${3:part2}(self) -> None:",
			"        pass",
			"",
			"class ${4:Builder}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${4:Builder}' objects.",
			"    It declares the interface for creating parts of a complex object.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def build_${2:part1}(self) -> ${4:Builder}:",
			"        \"\"\"",
			"        Abstract build_${2:part1} method. Needs to be implemented by concrete '${4:Builder}' objects.",
			"",
			"		Returns:",
			"            ${4:Builder}: The builder object.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def build_${3:part2}(self) -> ${4:Builder}:",
			"        \"\"\"",
			"        Abstract build_${3:part2} method. Needs to be implemented by concrete '${4:Builder}' objects.",
			"",
			"		Returns:",
			"            ${4:Builder}: The builder object.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteBuilder}(${4:Builder}):",
			"    \"\"\"",
			"    Concrete builder class that implements the '${4:Builder}' interface.",
			"    It constructs and assembles parts of the product by implementing the builder interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self.reset()",
			"",
			"    def reset(self) -> None:",
			"        self._product = ${1:Product}()",
			"",
			"    @property",
			"    def product(self) -> ${1:Product}:",
			"    	\"\"\"",
			"    	Returns the product that was built.",
			"    	\"\"\"",
			"        product = self._product",
			"        self.reset()",
			"        return product",
			"",
			"    def build_${2:part1}(self) -> ${7:ConcreteBuilder}:",
			"    	\"\"\"",
			"    	Ovverides the build_${2:part1} method to add '${2:part1}' to the product.",
			"",
			"		Returns:",
			"            ${7:ConcreteBuilder}: The builder object.",
			"    	\"\"\"",
			"        self._product.add_${2:part1}()",
			"        return self",
			"",
			"    def build_${3:part2}(self) -> ${7:ConcreteBuilder}:",
			"    	\"\"\"",
			"		Ovverides the build_${3:part2} method to add '${3:part2}' to the product.",
			"",
			"		Returns:",
			"            ${7:ConcreteBuilder}: The builder object.",
			"    	\"\"\"",
			"        self._product.add_${3:part2}()",
			"        return self",
			""
		],
		"description": "Constructs a Builder design pattern structure in Python.\nDefines:\n- A product class with complex construction.\n- An abstract builder class with methods for building parts of the product.\n- A concrete builder class that implements the builder interface.\nThis pattern enables the step-by-step construction of a complex object.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Product\nclass Coffee:\n    def __init__(self) -> None:\n        self.parts = []\n\n    def add_beans(self) -> None:\n        self.parts.append(\"Coffee Beans\")\n\n    def add_water(self) -> None:\n        self.parts.append(\"Water\")\n\n# Builder\nclass CoffeeBuilder(ABC):\n    @abstractmethod\n    def build_beans(self) -> None:\n        pass\n\n    @abstractmethod\n    def build_water(self) -> None:\n        pass\n\n# ConcreteBuilder\nclass CoffeeMachine(CoffeeBuilder):\n    def __init__(self) -> None:\n        self.reset()\n\n    def reset(self) -> None:\n        self._coffee = Coffee()\n\n    @property\n    def coffee(self) -> Coffee:\n        coffee = self._coffee\n        self.reset()\n        return coffee\n\n    def build_beans(self) -> None:\n        self._coffee.add_beans()\n\n    def build_water(self) -> None:\n        self._coffee.add_water()\n\n# Client\ndef main() -> None:\n    coffee_machine = CoffeeMachine()\n    coffee_machine.build_beans()\n    coffee_machine.build_water()\n    coffee = coffee_machine.coffee\n\nif __name__ == \"__main__\":\n    main()"
	},

	"Builder With Director": {
		"scope": "python",
		"prefix": "!builder_director",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Product}:",
			"    \"\"\"",
			"    Represents the complex object under construction.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        \"\"\"",
			"        Defines the object to be built.",
			"        \"\"\"",
			"        pass",
			"",
			"    def add_${2:part1}(self) -> None:",
			"        pass",
			"",
			"    def add_${3:part2}(self) -> None:",
			"        pass",
			"",
			"class ${4:Builder}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${4:Builder}' objects.",
			"    It declares the interface for creating parts of a complex object.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def build_${2:part1}(self) -> ${4:Builder}:",
			"        \"\"\"",
			"        Abstract build_${2:part1} method. Needs to be implemented by concrete '${4:Builder}' objects.",
			"",
			"		Returns:",
			"            ${4:Builder}: The builder object.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def build_${3:part2}(self) -> ${4:Builder}:",
			"        \"\"\"",
			"        Abstract build_${3:part2} method. Needs to be implemented by concrete '${4:Builder}' objects.",
			"",
			"		Returns:",
			"            ${4:Builder}: The builder object.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteBuilder}(${4:Builder}):",
			"    \"\"\"",
			"    Concrete builder class that implements the '${4:Builder}' interface.",
			"    It constructs and assembles parts of the product by implementing the builder interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self.reset()",
			"",
			"    def reset(self) -> None:",
			"        self._product = ${1:Product}()",
			"",
			"    @property",
			"    def product(self) -> ${1:Product}:",
			"    	\"\"\"",
			"    	Returns the product that was built.",
			"    	\"\"\"",
			"        product = self._product",
			"        self.reset()",
			"        return product",
			"",
			"    def build_${2:part1}(self) -> ${7:ConcreteBuilder}:",
			"    	\"\"\"",
			"    	Ovverides the build_${2:part1} method to add '${2:part1}' to the product.",
			"",
			"		Returns:",
			"            ${7:ConcreteBuilder}: The builder object.",
			"    	\"\"\"",
			"        self._product.add_${2:part1}()",
			"        return self",
			"",
			"    def build_${3:part2}(self) -> ${7:ConcreteBuilder}:",
			"    	\"\"\"",
			"		Ovverides the build_${3:part2} method to add '${3:part2}' to the product.",
			"",
			"		Returns:",
			"            ${7:ConcreteBuilder}: The builder object.",
			"    	\"\"\"",
			"        self._product.add_${3:part2}()",
			"        return self",
			"",
			"class ${8:Director}:",
			"    \"\"\"",
			"    Director class that constructs a product using a builder.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self._builder = None",
			"",
			"    @property",
			"    def builder(self) -> ${7:ConcreteBuilder}:",
			"    	\"\"\"",
			"    	Returns the builder that was set.",
			"    	\"\"\"",
			"        return self._builder",
			"",
			"    @builder.setter",
			"    def builder(self, builder: ${4:Builder}) -> None:",
			"        self._builder = builder",
			"",
			"    def build_${9:product}(self) -> None:",
			"        self.builder \\",
			"            .build_${2:part1}() \\",
			"            .build_${3:part2}()",
			"",
			"    def get_product(self) -> ${1:Product}:",
			"    	\"\"\"",
			"    	Returns the product that was built.",
			"    	\"\"\"",
			"        return self.builder.product",
			""
		],
		"description": "Creates a Builder design pattern structure with a Director in Python.\nCombines the Builder and Director patterns to facilitate the construction of a complex object.\nThe Director class orchestrates the building process using a builder, ensuring a consistent construction sequence.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Product\nclass Coffee:\n    def __init__(self) -> None:\n        self.parts = []\n\n    def add_beans(self) -> None:\n        self.parts.append(\"Coffee Beans\")\n\n    def add_water(self) -> None:\n        self.parts.append(\"Water\")\n\n# Builder\nclass CoffeeBuilder(ABC):\n    @abstractmethod\n    def build_beans(self) -> None:\n        pass\n\n    @abstractmethod\n    def build_water(self) -> None:\n        pass\n\n# ConcreteBuilder\nclass CoffeeMachine(CoffeeBuilder):\n    def __init__(self) -> None:\n        self.reset()\n\n    def reset(self) -> None:\n        self._coffee = Coffee()\n\n    @property\n    def coffee(self) -> Coffee:\n        coffee = self._coffee\n        self.reset()\n        return coffee\n\n    def build_beans(self) -> None:\n        self._coffee.add_beans()\n\n    def build_water(self) -> None:\n        self._coffee.add_water()\n\n# Director\nclass Barista:\n    def __init__(self) -> None:\n        self._builder = None\n\n    @property\n    def builder(self) -> CoffeeBuilder:\n        return self._builder\n\n    @builder.setter\n    def builder(self, builder: CoffeeBuilder) -> None:\n        self._builder = builder\n\n    def build_coffee(self) -> None:\n        self.builder \\\n            .build_beans() \\\n            .build_water()\n\n    def get_coffee(self) -> Coffee:\n        return self.builder.coffee\n\n# Client\ndef main() -> None:\n    barista = Barista()\n    coffee_machine = CoffeeMachine()\n\n    barista.builder = coffee_machine\n    barista.build_coffee()\n    coffee = barista.get_coffee()\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Singleton": {
		"scope": "python",
		"prefix": "!singleton",
		"body": [
			"from __future__ import annotations",
			"from typing import Any, Dict",
			"",
			"class ${1:SingletonMeta}(type):",
			"    \"\"\"",
			"    Metaclass implementing the Singleton design pattern.",
			"    \"\"\"",
			"    _instances: Dict[${1:SingletonMeta}, Any] = {}",
			"",
			"    def __call__(cls, *args, **kwargs):",
			"        \"\"\"",
			"        Override the default behavior of creating instances.",
			"        Ensures that only one instance of the class exists.",
			"        \"\"\"",
			"        if cls not in cls._instances:",
			"            cls._instances[cls] = super().__call__(*args, **kwargs)",
			"        return cls._instances[cls]",
			"",
			"class ${2:Singleton}(metaclass=${1:SingletonMeta}):",
			"    \"\"\"",
			"    Singleton class implementing the Singleton design pattern.",
			"    \"\"\"",
			"    def ${3:operation}(self) -> None:",
			"        \"\"\"",
			"        Placeholder for the operation that the Singleton performs.",
			"        Replace this with the actual functionality of your Singleton.",
			"        \"\"\"",
			"        pass",
			""
		],
		"description": "Implements the Singleton design pattern in Python.\nEnsures a class has only one instance and provides a global point of access to it.\nThis pattern involves a single class that is responsible for creating its own unique instance and ensuring that only a single instance exists.\n\nExample:\nclass SingletonMeta(type):\n    _instances: Dict[${1:SingletonMeta}, Any] = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n# Singleton\nclass CoffeeCup(metaclass=SingletonMeta):\n    def __init__(self) -> None:\n        self.coffee: float = 1.0\n\n    def drink(self, amount: float) -> None:\n        self.coffee -= amount\n\n    def coffee_left(self) -> float:\n        return self.coffee\n\n# Client\ndef main() -> None:\n    cup1 = CoffeeCup()\n    cup2 = CoffeeCup()\n\n    cup1.drink(0.5)\n    cup2.drink(0.25)\n\n    print(cup1.coffee_left()) # 0.25\n    print(cup2.coffee_left()) # 0.25\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Singleton Thread-Safe ": {
		"scope": "python",
		"prefix": "!singleton_thread_safe",
		"body": [
			"from __future__ import annotations"
			"from typing import Any, Dict",
			"from threading import Lock",
			"",
			"class ${1:SingletonMeta}(type):",
			"    \"\"\"",
			"    Metaclass implementing the Singleton design pattern.",
			"    \"\"\"",
			"    _instances: Dict[SingletonMeta, Any] = {}",
			"    _lock: Lock = Lock()",
			"",
			"    def __call__(cls, *args, **kwargs):",
			"        \"\"\"",
			"        Override the default behavior of creating instances.",
			"        Ensures that only one instance of the class exists.",
			"        \"\"\"",
			"        with cls._lock:",
			"            if cls not in cls._instances:",
			"                cls._instances[cls] = super().__call__(*args, **kwargs)",
			"        return cls._instances[cls]",
			"",
			"class ${2:Singleton}(metaclass=${1:SingletonMeta}):",
			"    \"\"\"",
			"    Singleton class implementing the Singleton design pattern.",
			"    \"\"\"",
			"    _internal_lock: Lock = Lock()",
			"    def ${3:operation}(self) -> None:",
			"        \"\"\"",
			"        Placeholder for the operation that the Singleton performs.",
			"        Replace this with the actual functionality of your Singleton.",
			"        \"\"\"",
			"        with self._internal_lock:",
			"            # Perform thread-safe operations here",
			"            pass",
			""
		],
		"description": "Implements the Thread-Safe Singleton design pattern in Python.\nEnsures that a class has only one instance and provides a global point of access to it, while being thread-safe.\nThis pattern involves using a lock or other mechanism to synchronize access to the singleton instance, preventing multiple threads from creating multiple instances simultaneously.\n\nExample:\nfrom __future__ import annotations\nfrom typing import Any, Dict\nfrom threading import Lock, Thread\n\nclass SingletonMeta(type):\n    _instances: Dict[${1:SingletonMeta}, Any] = {}\n    _lock: Lock = Lock()\n\n    def __call__(cls, *args, **kwargs):\n        with cls._lock:\n            if cls not in cls._instances:\n                cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n# Singleton\nclass CoffeeShop(metaclass=SingletonMeta):\n    _internal_lock: Lock = Lock()\n    def __init__(self, name: str, owner: str) -> None:\n        self.name = name\n        self.owner = owner\n\n# Client\ndef main() -> None:\n    def create_coffee_shop(name: str, owner: str) -> None:\n        coffee_shop = CoffeeShop(name, owner)\n        print(f\"Created coffee shop {coffee_shop.name} owned by {coffee_shop.owner}\")\n\n    starbucks = Thread(target=create_coffee_shop, args=(\"Starbucks\", \"Howard Schultz\"))\n    dunkin = Thread(target=create_coffee_shop, args=(\"Dunkin\", \"William Rosenberg\"))\n\n    starbucks.start()\n    dunkin.start()\n    starbucks.join()\n    dunkin.join()\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Prototype": {
		"scope": "python",
		"prefix": "!prototype",
		"body": [
			"from __future__ import annotations",
			"from typing import Any, Dict",
			"import copy",
			"",
			"class ${1:Prototype}:",
			"    \"\"\"",
			"    Prototype class implementing the Prototype design pattern.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        \"\"\"",
			"        Initialize the Prototype object.",
			"        \"\"\"",
			"        pass",
			"",
			"    def __copy__(self) -> ${1:Prototype}:",
			"        \"\"\"",
			"        Create a shallow copy of the object.",
			"        \"\"\"",
			"        # Perform a shallow copy of the object's attributes.",
			"        new = self.__class__()",
			"        new.__dict__.update(self.__dict__)",
			"        return new",
			"",
			"    def __deepcopy__(self, memo: Dict[int, Any]=None) -> ${1:Prototype}:",
			"        \"\"\"",
			"        Create a deep copy of the object.",
			"        \"\"\"",
			"        if memo is None:",
			"            memo = {}",
			"",
			"        # Perform a deep copy of the object's attributes.",
			"        new = self.__class__()",
			"        new.__dict__ = copy.deepcopy(self.__dict__, memo)",
			"        return new",
			""
		],
		"description": "Implements the Prototype design pattern in Python.\nIntroduces a prototype class that defines the object to be cloned.\nOffers methods for creating shallow and deep copies of the object, allowing flexible instantiation of similar objects without specifying their classes.\n\nExample:\nfrom __future__ import annotations\nfrom typing import Any, Dict, List\nimport copy\n\n# Prototype\nclass Coffee:\n    def __init__(self, name: str, strength: int, ingredients: List[str]) -> None:\n        self.name = name\n        self.strength = strength\n        self.ingredients = ingredients\n\n    def __copy__(self) -> Coffee:\n        new = self.__class__(self.name, self.strength, self.ingredients)\n        new.__dict__.update(self.__dict__)\n        return new\n\n    def __deepcopy__(self, memo: Dict[int, Any]=None) -> Coffee:\n        if memo is None:\n            memo = {}\n\n        new = self.__class__(self.name, self.strength, self.ingredients)\n        new.__dict__ = copy.deepcopy(self.__dict__, memo)\n        return new\n\n# Client\ndef main() -> None:\n    latte = Coffee(\"Latte\", 5, [\"Espresso\", \"Steamed Milk\"])\n    # Shallow copy\n    cappuccino = copy.copy(latte)\n    # Deep copy\n    mocha = copy.deepcopy(latte)\n\n    cappuccino.name = \"Cappuccino\"\n    cappuccino.ingredients.remove(\"Steamed Milk\")\n    cappuccino.ingredients.append(\"Foamed Milk\")\n\n    mocha.name = \"Mocha\"\n    mocha.ingredients.append(\"Chocolate Syrup\")\n\n    print(latte.name) # Latte\n    print(latte.ingredients) # [\"Espresso\", \"Foamed Milk\"]\n\n    print(cappuccino.name) # Cappuccino\n    print(cappuccino.ingredients) # [\"Espresso\", \"Foamed Milk\"]\n\n    print(mocha.name) # Mocha\n    print(mocha.ingredients) # [\"Espresso\", \"Steamed Milk\", \"Chocolate Syrup\"]\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Adapter with Inheritance": {
		"scope": "python",
		"prefix": "!adapter_inheritance",
		"body": [
			"class ${2:Adaptee}:",
			"    \"\"\"",
			"    Adaptee class with functionality to be adapted.",
			"    \"\"\"",
			"    def ${4:adaptee_method}(self) -> None:",
			"        # Adaptee's method implementation",
			"        pass",
			"",
			"class ${1:Adapter}(${2:Adaptee}):",
			"    \"\"\"",
			"    Adapter class that inherits from the Adaptee class.",
			"    Implements the target interface while reusing functionality from ${2:Adaptee}.",
			"    \"\"\"",
			"    def ${3:target_method}(self) -> None:",
			"        # Implement the target interface by delegating to ${2:Adaptee}'s method",
			"        self.${4:adaptee_method}()"
		],
		"description": "Implements the Adapter design pattern using inheritance.\nAdapts an Adaptee class to the target interface by inheriting from the Adaptee class and implementing the target interface.\n\nExample:\n# Adaptee\nclass DecafCoffee:\n    def throw_away(self) -> None:\n        print(\"Pouring decaf coffee down the drain...\")\n\n# Adapter\nclass RealCoffeeAdapter(DecafCoffee):\n    def drink(self) -> None:\n        self.throw_away()\n\n# Client\ndef main() -> None:\n    coffee = RealCoffeeAdapter()\n    coffee.drink() # Pouring decaf coffee down the drain...\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Adapter with Object Composition": {
		"scope": "python",
		"prefix": "!adapter_composition",
		"body": [
			"class ${2:Adaptee}:",
			"    \"\"\"",
			"    Adaptee class with functionality to be adapted.",
			"    \"\"\"",
			"    def ${4:adaptee_method}(self) -> None:",
			"        # Adaptee's method implementation",
			"        pass",
			"",
			"class ${1:Adapter}:",
			"    \"\"\"",
			"    Adapter class that uses object composition to adapt an Adaptee class.",
			"    Implements the target interface by composing an instance of ${2:Adaptee}.",
			"    \"\"\"",
			"    def __init__(self, adaptee: ${2:Adaptee}):",
			"        self.adaptee: ${2:Adaptee} = adaptee",
			"",
			"    def ${3:target_method}(self) -> None:",
			"        # Implement the target interface by delegating to ${2:Adaptee}'s method",
			"        self.adaptee.${4:adaptee_method}()"
		],
		"description": "Implements the Adapter design pattern using object composition.\nAdapts an Adaptee class to the target interface by composing an instance of Adaptee within the Adapter class and implementing the target interface.\n\nExample:\n# Adaptee\nclass DecafCoffee:\n    def throw_away(self) -> None:\n        print(\"Pouring decaf coffee down the drain...\")\n\n# Adapter\nclass RealCoffeeAdapter:\n    def __init__(self, adaptee: DecafCoffee):\n        self.adaptee: DecafCoffee = adaptee\n\n    def drink(self) -> None:\n        self.adaptee.throw_away()\n\n# Client\ndef main() -> None:\n    decaf_coffee = DecafCoffee()\n    coffee = RealCoffeeAdapter(decaf_coffee)\n    coffee.drink() # Pouring decaf coffee down the drain...\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Bridge": {
		"scope": "python",
		"prefix": "!bridge",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Abstraction}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Abstraction}' objects.",
			"    It defines the abstraction's interface and maintains a reference to an object of type '${2:Implementor}'.",
			"    \"\"\"",
			"    def __init__(self, ${2:implementor}: ${3:Implementor}) -> None:",
			"        self.${2:implementor}: ${3:Implementor} = ${2:implementor}",
			"",
			"    @abstractmethod",
			"    def ${4:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${4:operation}' method. Needs to be implemented by concrete '${1:Abstraction}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${5:RefinedAbstractionA}(${1:Abstraction}):",
			"    \"\"\"",
			"    Refined abstraction class that extends the interface defined by '${1:Abstraction}'.",
			"    \"\"\"",
			"    def ${4:operation}(self) -> None:",
			"        # Delegate the implementation to the '${2:Implementor}' object",
			"        self.${2:implementor}.${4:operation}()",
			"",
			"class ${6:RefinedAbstractionB}(${1:Abstraction}):",
			"    \"\"\"",
			"    Another refined abstraction class that extends the interface defined by '${1:Abstraction}'.",
			"    \"\"\"",
			"    def ${4:operation}(self) -> None:",
			"        # Delegate the implementation to the '${2:Implementor}' object",
			"        self.${2:implementor}.${4:operation}()",
			"",
			"class ${2:Implementor}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${2:Implementor}' objects.",
			"    It defines the interface for implementation classes.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${4:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${4:operation}' method. Needs to be implemented by concrete '${2:Implementor}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteImplementorA}(${2:Implementor}):",
			"    \"\"\"",
			"    Concrete implementation class that implements the '${2:Implementor}' interface.",
			"    \"\"\"",
			"    def ${4:operation}(self) -> None:",
			"        pass",
			"",
			"class ${8:ConcreteImplementorB}(${2:Implementor}):",
			"    \"\"\"",
			"    Another concrete implementation class that implements the '${2:Implementor}' interface.",
			"    \"\"\"",
			"    def ${4:operation}(self) -> None:",
			"        pass",
			""
		],
		"description": "Implements the Bridge design pattern in Python.\nDefines:\n- An abstract class for the abstraction.\n- Concrete classes that extend the abstraction.\n- An abstract class for the implementor.\n- Concrete classes that implement the implementor interface.\nThis pattern decouples the abstraction from its implementation, allowing both to vary independently.\n\nExample:\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\n\n# Abstraction\nclass CoffeeMachine(ABC):\n    def __init__(self, implementor: CoffeeMachineImplementor) -> None:\n        self.implementor: CoffeeMachineImplementor = implementor\n\n    @abstractmethod\n    def brew(self) -> None:\n        pass\n\n# Refined Abstraction\nclass DripCoffeeMachine(CoffeeMachine):\n    def brew(self) -> None:\n        self.implementor.brew_filter_coffee()\n\n# Implementor\nclass CoffeeMachineImplementor(ABC):\n    @abstractmethod\n    def brew_filter_coffee(self) -> None:\n        pass\n\n# Concrete Implementor\nclass ElectricCoffeeMachine(CoffeeMachineImplementor):\n    def brew_filter_coffee(self) -> None:\n        print(\"Brewing filter coffee with an electric coffee machine...\")\n\n# Client\ndef main() -> None:\n    electric_coffee_machine = ElectricCoffeeMachine()\n    drip_coffee_machine = DripCoffeeMachine(electric_coffee_machine)\n    drip_coffee_machine.brew() # Brewing filter coffee with an electric coffee machine...\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Decorator": {
		"scope": "python",
		"prefix": "!decorator",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Component}(ABC):",
			"    \"\"\"",
			"    Component: Abstract base class for '${1:Component}' objects.",
			"    Define the interface for concrete components.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${2:operation}' method. Needs to be implemented by concrete components.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:ConcreteComponent}(${1:Component}):",
			"    \"\"\"",
			"    ConcreteComponent: Concrete component class that implements the '${1:Component}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:Decorator}(ABC):",
			"    \"\"\"",
			"    Decorator: Abstract base class for decorators.",
			"    Maintains a reference to a '${1:Component}' object and also conforms to the '${1:Component}' interface.",
			"    \"\"\"",
			"    def __init__(self, ${5:component}: ${1:Component}) -> None:",
			"        self.${5:component}: ${1:Component} = ${5:component}",
			"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${2:operation}' method. Needs to be implemented by concrete decorators.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${6:ConcreteDecorator}(${4:Decorator}):",
			"    \"\"\"",
			"    ConcreteDecorator: Concrete decorator class that extends the functionality of the '${1:Component}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        # Additional functionality here",
			"        self.${5:component}.${2:operation}()"
		],
		"description": "Implements the Decorator design pattern in Python.\nAttaches additional responsibilities to an object dynamically.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Component\nclass Coffee(ABC):\n    @abstractmethod\n    def drink(self) -> None:\n        pass\n\n# Concrete Component\nclass Latte(Coffee):\n    def drink(self) -> None:\n        print(\"Drinking a latte...\")\n\n# Decorator\nclass LatteWithCinnamon(Coffee):\n    def __init__(self, coffee: Coffee) -> None:\n        self.coffee: Coffee = coffee\n\n    def drink(self) -> None:\n        print(\"Adding cinnamon topping...\")\n        self.coffee.drink()\n\n# Client\ndef main() -> None:\n    latte = Latte()\n    latte_with_cinamon = LatteWithCinamon(latte)\n    latte_with_cinamon.drink() # Adding cinnamon topping... \\n Drinking a latte...\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Proxy": {
		"scope": "python",
		"prefix": "!proxy",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Subject}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Subject}' objects.",
			"    Defines the interface for the real object and its proxy.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract method '${2:operation}'. Must be implemented by real subjects and proxies.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:RealSubject}(${1:Subject}):",
			"    \"\"\"",
			"    Real subject class that implements the '${1:Subject}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:Proxy}(${1:Subject}):",
			"    \"\"\"",
			"    Proxy class that implements the '${1:Subject}' interface.",
			"    Maintains a reference to the real subject and controls access to it.",
			"    \"\"\"",
			"    def __init__(self, ${5:real_subject}: ${3:RealSubject}) -> None:",
			"        \"\"\"",
			"        Initialize the Proxy with a reference to the real subject.",
			"        \"\"\"",
			"        self._${5:real_subject}: ${3:RealSubject} = ${5:real_subject}",
			"",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Perform the operation, checking authorization before delegating to the real subject.",
			"        \"\"\"",
			"        if self.${6:is_authorized}():",
			"            self._${5:real_subject}.${2:operation}()",
			"",
			"    def ${6:is_authorized}(self) -> bool:",
			"        \"\"\"",
			"        Check if the user is authorized to access the real subject.",
			"        \"\"\"",
			"        return True"
		],
		"description": "Implements the Proxy design pattern in Python.\nProvides a surrogate or placeholder for another object to control access to it.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Subject\nclass CoffeeShop(ABC):\n    @abstractmethod\n    def serve_coffee(self) -> None:\n        pass\n\n# Real Subject\nclass Starbucks(CoffeeShop):\n    def serve_coffee(self) -> None:\n        print(\"Serving coffee...\")\n\n# Proxy\nclass StarbucksProxy(CoffeeShop):\n    def __init__(self, starbucks: Starbucks, is_barista: bool) -> None:\n        self._real_subject: Starbucks = starbucks\n        self._is_barista: bool = is_barista\n\n    def serve_coffee(self) -> None:\n        if self.is_authorized():\n            self.starbucks.serve_coffee()\n        else:\n            print(\"Please get out of the counter area...\")\n\n    def is_authorized(self) -> bool:\n        return self._is_barista\n\n# Client\ndef main() -> None:\n    starbucks = Starbucks()\n    barista = StarbucksProxy(starbucks, is_barista=True)\n    barista.serve_coffee() # Serving coffee...\n\n    annoying_customer = StarbucksProxy(starbucks, is_barista=False)\n    annoying_customer.serve_coffee() # Please get out of the counter area...\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Strategy": {
		"scope": "python",
		"prefix": "!strategy",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Strategy}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Strategy}' objects.",
			"    Defines the interface for all concrete strategies.",
			"    \"\"\"",
			"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${2:operation}' method. Must be implemented by concrete strategies.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:ConcreteStrategyA}(${1:Strategy}):",
			"    \"\"\"",
			"    Concrete strategy class that implements the '${1:Strategy}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:ConcreteStrategyB}(${1:Strategy}):",
			"    \"\"\"",
			"    Another concrete strategy class that implements the '${1:Strategy}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${5:Context}:",
			"    \"\"\"",
			"    Context class that uses a strategy.",
			"    \"\"\"",
			"    def __init__(self, ${6:strategy}: ${1:Strategy}) -> None:",
			"        self._${6:strategy}: ${1:Strategy} = ${6:strategy}",
			"",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Perform the operation by delegating to the strategy.",
			"        \"\"\"",
			"        self._${6:strategy}.${2:operation}()"
		],
		"description": "Implements the Strategy design pattern in Python.\nDefines a family of algorithms, encapsulates each one, and makes them interchangeable.\nAllows the algorithm to vary independently from clients that use it.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Strategy\nclass BrewStrategy(ABC):\n    @abstractmethod\n    def brew(self) -> None:\n        pass\n\n# Concrete Strategy A\nclass DripBrewStrategy(BrewStrategy):\n    def brew(self) -> None:\n        print(\"Brewing coffee using the drip method...\")\n\n# Concrete Strategy B\nclass FrenchPressBrewStrategy(BrewStrategy):\n    def brew(self) -> None:\n        print(\"Brewing coffee using the French press method...\")\n\n# Context\nclass CoffeeMaker:\n    def __init__(self, brew_strategy: BrewStrategy) -> None:\n        self._brew_strategy: BrewStrategy = brew_strategy\n\n    def brew(self) -> None:\n        self._brew_strategy.brew()\n\n# Client\ndef main() -> None:\n    drip_brew_strategy = DripBrewStrategy()\n    coffee_maker = CoffeeMaker(drip_brew_strategy)\n    coffee_maker.brew() # Brewing coffee using the drip method...\n\n    french_press_brew_strategy = FrenchPressBrewStrategy()\n    coffee_maker = CoffeeMaker(french_press_brew_strategy)\n    coffee_maker.brew() # Brewing coffee using the French press method...\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Template Method": {
		"scope": "python",
		"prefix": "!template_method",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:AbstractClass}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:AbstractClass}' objects.",
			"    Defines abstract primitive operations that concrete subclasses define to implement steps of an algorithm.",
			"    Implements a template method defining the algorithm's skeleton.",
			"    \"\"\"",
			"    def ${2:template_method}(self) -> None:",
			"        \"\"\"",
			"        Defines the skeleton of an algorithm.",
			"        \"\"\"",
			"        self.${3:primitive_operation_1}()",
			"        self.${4:primitive_operation_2}()",
			"        self.${5:required_operation_1}()",
			"        self.${6:hook_1}()",
			"        self.${7:required_operation_2}()",
			"        self.${8:hook_2}()",
			"",
			"	@abstractmethod",
			"    def ${3:primitive_operation_1}(self) -> None:",
			"        \"\"\"",
			"        Abstract primitive operation that must be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"	@abstractmethod",
			"    def ${4:primitive_operation_2}(self) -> None:",
			"        \"\"\"",
			"        Another abstract primitive operation that must be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${5:required_operation_1}(self) -> None:",
			"        \"\"\"",
			"        Abstract operation that must be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${7:required_operation_2}(self) -> None:",
			"        \"\"\"",
			"        Another abstract operation that must be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"    def ${6:hook_1}(self) -> None:",
			"        \"\"\"",
			"        A hook that can be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"    def ${8:hook_2}(self) -> None:",
			"        \"\"\"",
			"        Another hook that can be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${9:ConcreteClass}(${1:AbstractClass}):",
			"    \"\"\"",
			"    Concrete subclass that implements the '${1:AbstractClass}' interface.",
			"    \"\"\"",
			"	def ${3:primitive_operation_1}(self) -> None:",
			"        pass",
			"",
			"    def ${4:primitive_operation_2}(self) -> None:",
			"        pass",
			"",
			"    def ${5:required_operation_1}(self) -> None:",
			"        pass",
			"",
			"    def ${7:required_operation_2}(self) -> None:",
			"        pass"
		],
		"description": "Implements the Template Method design pattern in Python.\nDefines the algorithm's skeleton in an operation, allowing subclasses to customize specific steps without changing the overall structure.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Abstract Class\nclass Coffee(ABC):\n    def prepare(self) -> None:\n        self.boil_water()\n        self.brew_coffee_grounds()\n        self.pour_in_cup()\n        self.add_condiments()\n        self.custom_hook()\n\n    @abstractmethod\n    def boil_water(self) -> None:\n        pass\n\n    @abstractmethod\n    def brew_coffee_grounds(self) -> None:\n        pass\n\n    @abstractmethod\n    def pour_in_cup(self) -> None:\n        pass\n\n    @abstractmethod\n    def add_condiments(self) -> None:\n        pass\n\n    def custom_hook(self) -> None:\n        pass\n\n# Concrete Class \nclass Latte(Coffee):\n    def boil_water(self) -> None:\n        print(\"Boiling 200ml of water.\")\n\n    def brew_coffee_grounds(self) -> None:\n        print(\"Brewing 20g of coffee grounds in hot water.\")\n\n    def pour_in_cup(self) -> None:\n        print(\"Pouring the brewed coffee into a latte cup\")\n\n    def add_condiments(self) -> None:\n        print(\"Steaming and frothing 100ml of milk; adding it to the latte. Sprinkling a pinch of cocoa powder on top.\")\n\n    def custom_hook(self) -> None:\n        print(\"Customizing the latte with a decorative swirl pattern on the foam.\")\n\n# Concrete Class B\nclass Espresso(Coffee):\n    def boil_water(self) -> None:\n        print(\"Boiling 50ml of water.\")\n\n    def brew_coffee_grounds(self) -> None:\n        print(\"Brewing 15g of finely ground coffee beans for a strong espresso shot.\")\n\n    def pour_in_cup(self) -> None:\n        print(\"Pouring the intense espresso shot into a small espresso cup.\")\n\n    def add_condiments(self) -> None:\n        print(\"No condiments added to the pure espresso. It's served as is.\")\n\n# Client\ndef main() -> None:\n    latte = Latte()\n    latte.prepare()\n    # Boiling 200ml of water.\n    # Brewing 20g of coffee grounds in hot water.\n    # Pouring the brewed coffee into a latte cup\n    # Steaming and frothing 100ml of milk; adding it to the latte. Sprinkling a pinch of cocoa powder on top.\n    # Customizing the latte with a decorative swirl pattern on the foam.\n\n    espresso = Espresso()\n    espresso.prepare()\n    # Boiling 50ml of water.\n    # Brewing 15g of finely ground coffee beans for a strong espresso shot.\n    # Pouring the intense espresso shot into a small espresso cup.\n    # No condiments added to the pure espresso. It's served as is.\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Observer": {
		"scope": "python",
		"prefix": "!observer",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"from typing import List",
			"",
			"class ${1:Subject}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Subject}' objects.",
			"    Maintains a list of observers and notifies them of state changes.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:attach}(self, observer: ${6:Observer}) -> None:",
			"        \"\"\"",
			"        Attach an observer to the subject.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${3:detach}(self, observer: ${6:Observer}) -> None:",
			"        \"\"\"",
			"        Detach an observer from the subject.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${4:notify}(self) -> None:",
			"        \"\"\"",
			"        Notify all observers about an event.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${5:ConcreteSubject}(${1:Subject}):",
			"    \"\"\"",
			"    Concrete subject class that extends the '${1:Subject}' interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self._observers: List[${6:Observer}] = []",
			"",
			"    def ${2:attach}(self, observer: ${6:Observer}) -> None:",
			"        self._observers.append(observer)",
			"",
			"    def ${3:detach}(self, observer: ${6:Observer}) -> None:",
			"        self._observers.remove(observer)",
			"",
			"    def ${4:notify}(self) -> None:",
			"        for observer in self._observers:",
			"            observer.${7:update}(self)",
			"",
			"class ${6:Observer}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${6:Observer}' objects.",
			"    Defines an updating interface for objects that should be notified of changes in a subject.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${7:update}(self, subject: ${1:Subject}) -> None:",
			"        \"\"\"",
			"        Receive update from the subject.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${8:ConcreteObserver}(${6:Observer}):",
			"    \"\"\"",
			"    Concrete observer class that implements the '${6:Observer}' interface.",
			"    \"\"\"",
			"    def ${7:update}(self, subject: ${1:Subject}) -> None:",
			"        pass"
		],
		"description": "Implements the Observer design pattern in Python.\nDefines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\n\nExample:\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\n# Subject\nclass CoffeeShop(ABC):\n    def __init__(self) -> None:\n        self._observers: List[Customer] = []\n\n    def attach(self, observer: Customer) -> None:\n        self._observers.append(observer)\n\n    def detach(self, observer: Customer) -> None:\n        self._observers.remove(observer)\n\n    def notify(self) -> None:\n        for observer in self._observers:\n            observer.update(self)\n\n# Concrete Subject\nclass Starbucks(CoffeeShop):\n    def __init__(self) -> None:\n        super().__init__()\n        self._coffee: str = \"\"\n\n    @property\n    def coffee(self) -> str:\n        return self._coffee\n\n    @coffee.setter\n    def coffee(self, coffee: str) -> None:\n        self._coffee = coffee\n        self.notify()\n\n# Observer\nclass Customer(ABC):\n    @abstractmethod\n    def update(self, coffee_shop: CoffeeShop) -> None:\n        pass\n\n# Concrete Observer\nclass CoffeeLover(Customer):\n    def update(self, coffee_shop: CoffeeShop) -> None:\n        print(f\"My favorite coffee shop just started serving {coffee_shop.coffee}!\")\n\n# Client\ndef main() -> None:\n    starbucks = Starbucks()\n    coffee_lover = CoffeeLover()\n    starbucks.attach(coffee_lover)\n    starbucks.coffee = \"Mystical Mocha Madness\" # My favorite coffee shop just started serving Mystical Mocha Madness!\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Chain of Responsibility": {
		"scope": "python",
		"prefix": "!chain_of_responsibility",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"from enum import Enum",
			"from typing import Any, Optional",
			"",
			"class ${1:RequestType}(Enum):",
			"    \"\"\"",
			"    Enumerates all supported request types.",
			"    \"\"\"",
			"    ${2:TYPE1} = 1",
			"    ${3:TYPE2} = 2",
			"    ${4:TYPE3} = 3",
			"",
			"class ${5:Request}:",
			"    \"\"\"",
			"    Represents a request in the chain of responsibility.",
			"    \"\"\"",
			"    def __init__(self, type: ${1:RequestType}, payload: Any) -> None:",
			"        self.type: ${1:RequestType} = type",
			"        self.payload: Any = payload",
			"",
			"class ${6:Handler}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${6:Handler}' objects.",
			"    Defines an interface for handling requests and implements the successor link.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${7:set_next}(self, handler: ${6:Handler}) -> ${6:Handler}:",
			"        \"\"\"",
			"        Set the next handler in the chain.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        \"\"\"",
			"        Handle the request.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${9:AbstractHandler}(${6:Handler}):",
			"    \"\"\"",
			"    Abstract handler class that implements the '${6:Handler}' interface.",
			"    \"\"\"",
			"    _next_handler: Optional[${6:Handler}] = None",
			"",
			"    def ${7:set_next}(self, handler: ${6:Handler}) -> ${6:Handler}:",
			"        self._next_handler = handler",
			"        return handler",
			"",
			"    @abstractmethod",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        \"\"\"",
			"        Handle the request.",
			"        \"\"\"",
			"        # The default behavior is to forward the request to the next handler.",
			"        if self._next_handler:",
			"            return self._next_handler.${8:handle}(request)",
			"        return None",
			"",
			"class ${10:ConcreteHandler1}(${9:AbstractHandler}):",
			"    \"\"\"",
			"    Concrete handler class that extends the '${9:AbstractHandler}' interface.",
			"    Responsible for handling requests of type '${2:TYPE1}'.",
			"    \"\"\"",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        if request.type == ${1:RequestType}.${2:TYPE1}:",
			"            # Handle the request",
			"            return request.payload",
			"        return super().${8:handle}(request)",
			"",
			"class ${11:ConcreteHandler2}(${9:AbstractHandler}):",
			"    \"\"\"",
			"    Concrete handler class that extends the '${9:AbstractHandler}' interface.",
			"    Responsible for handling requests of type '${3:TYPE2}'.",
			"    \"\"\"",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        if request.type == ${1:RequestType}.${3:TYPE2}:",
			"            # Handle the request",
			"            return request.payload",
			"        return super().${8:handle}(request)",
			"",
			"class ${12:ConcreteHandler3}(${9:AbstractHandler}):",
			"    \"\"\"",
			"    Concrete handler class that extends the '${9:AbstractHandler}' interface.",
			"    Responsible for handling requests of type '${4:TYPE3}'.",
			"    \"\"\"",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        if request.type == ${1:RequestType}.${4:TYPE3}:",
			"            # Handle the request",
			"            return request.payload",
			"        return super().${8:handle}(request)",
			""
		],
		"description": "Implements the Chain of Responsibility design pattern in Python.\nAvoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.\nChains the receiving objects and passes the request along the chain until an object handles it.\n\nExample:\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import Any, Optional\n\n# Enumerates all supported request types.\nclass RequestType(Enum):\n    LATTE = 1\n    ESPRESSO = 2\n    CAPPUCCINO = 3\n\n# Represents a request in the chain of responsibility.\nclass Request:\n    def __init__(self, type: RequestType, payload: Any) -> None:\n        self.type: RequestType = type\n        self.payload: Any = payload\n\n# Abstract base class for 'Handler' objects.\nclass Handler(ABC):\n    # Defines an interface for handling requests and implements the successor link.\n    def set_next(self, handler: Handler) -> Handler:\n        pass\n\n    @abstractmethod\n    def handle(self, request: Request) -> Any:\n        pass\n\n# Abstract handler class that implements the 'Handler' interface.\nclass AbstractHandler(Handler):\n    _next_handler: Optional[Handler] = None\n\n    def set_next(self, handler: Handler) -> Handler:\n        self._next_handler = handler\n        return handler\n\n    def handle(self, request: Request) -> Any:\n        # The default behavior is to forward the request to the next handler.\n        if self._next_handler:\n            return self._next_handler.handle(request)\n        return None\n\n# Concrete handler class that extends the 'AbstractHandler' interface.\nclass LatteHandler(AbstractHandler):\n    # Responsible for handling requests of type 'LATTE'.\n    def handle(self, request: Request) -> Any:\n        if request.type == RequestType.LATTE:\n            # Handle the request\n            details = request.payload\n            return f\"Making a Latte with {details['milk']} milk and {details['flavor']} flavor.\"\n        return super().handle(request)\n\n# Concrete handler class that extends the 'AbstractHandler' interface.\nclass EspressoHandler(AbstractHandler):\n    # Responsible for handling requests of type 'ESPRESSO'.\n    def handle(self, request: Request) -> Any:\n        if request.type == RequestType.ESPRESSO:\n            # Handle the request\n            details = request.payload\n            return f\"Preparing Espresso with {details['shots']} shots.\"\n        return super().handle(request)\n\n# Concrete handler class that extends the 'AbstractHandler' interface.\nclass CappuccinoHandler(AbstractHandler):\n    # Responsible for handling requests of type 'CAPPUCCINO'.\n    def handle(self, request: Request) -> Any:\n        if request.type == RequestType.CAPPUCCINO:\n            # Handle the request\n            details = request.payload\n            return f\"Brewing Cappuccino with {details['foam']} foam.\"\n        return super().handle(request)\n\n# Client\ndef main() -> None:\n    latte_handler = LatteHandler()\n    espresso_handler = EspressoHandler()\n    cappuccino_handler = CappuccinoHandler()\n\n    latte_handler.set_next(espresso_handler).set_next(cappuccino_handler)\n    coffee_orders_handlers = latte_handler\n\n    coffee_orders = [\n        Request(RequestType.LATTE, {\"milk\": \"whole\", \"flavor\": \"vanilla\"}),\n        Request(RequestType.ESPRESSO, {\"shots\": 2}),\n        Request(RequestType.CAPPUCCINO, {\"foam\": \"creamy\"}),\n        Request(RequestType.LATTE, {\"milk\": \"2%\", \"flavor\": \"caramel\"}),\n\n    for order in coffee_orders:\n        print(coffee_orders_handlers.handle(order))\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Memento": {
		"scope": "python",
		"prefix": "!memento",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"from typing import Any, List",
			"",
			"class ${1:Originator}:",
			"    \"\"\"",
			"    Originator class that creates a memento containing a snapshot of its current internal state.",
			"    \"\"\"",
			"    def __init__(self, state: Any) -> None:",
			"        self._state: Any = state",
			"",
			"    def ${2:save}(self) -> Memento:",
			"        \"\"\"",
			"        Save the current state inside a memento.",
			"        \"\"\"",
			"        return Memento(self._state)",
			"",
			"    def ${3:restore}(self, memento: Memento) -> None:",
			"        \"\"\"",
			"        Restore the internal state from a memento.",
			"        \"\"\"",
			"        self._state = memento.${5:get_state}()",
			"",
			"class ${4:Memento}(ABC):",
			"    \"\"\"",
			"    Abstract Memento class that stores the internal state of the originator.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${5:get_state}(self) -> Any:",
			"        \"\"\"",
			"        Abstract method that must be implemented by concrete mementos.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${6:ConcreteMemento}(${4:Memento}):",
			"    \"\"\"",
			"    Concrete memento class that extends the '${4:Memento}' interface.",
			"    \"\"\"",
			"    def __init__(self, state: Any) -> None:",
			"        self._state: Any = state",
			"",
			"    def ${5:get_state}(self) -> Any:",
			"        return self._state",
			"",
			"class ${7:Caretaker}:",
			"    \"\"\"",
			"    Caretaker class that keeps track of multiple mementos.",
			"    \"\"\"",
			"    def __init__(self, originator: ${1:Originator}) -> None:",
			"        self._originator: ${1:Originator} = originator",
			"        self._mementos: List[Memento] = []",
			"",
			"    def ${8:backup}(self) -> None:",
			"        \"\"\"",
			"        Save the current state of the originator inside a memento.",
			"        \"\"\"",
			"        self._mementos.append(self._originator.${2:save}())",
			"",
			"    def ${9:undo}(self) -> None:",
			"        \"\"\"",
			"        Restore the originator's state from the last memento in the list.",
			"        \"\"\"",
			"        if not self._mementos:",
			"            return",
			"        memento = self._mementos.pop()",
			"        self._originator.${3:restore}(memento)"
		],
		"description": "Implements the Memento design pattern in Python.\nCaptures and externalizes an object's internal state so that it can be restored to this state later, without violating encapsulation.\n\nExample:\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\nfrom typing import Any, List\n\n# Originator class that creates a memento containing a snapshot of its current internal state.\nclass Barista: \n    def __init__(self, current_order: Any) -> None:\n        self._current_order: Any = current_order\n \n    def take_order(self, coffee_type: str, size: str, extras: List[str]) -> None: \n		self._current_order = CoffeeOrder(coffee_type, size, extras)\n \n    def save_order(self) -> CoffeeOrder: \n        return CoffeeOrder(self._current_order.coffee_type, self._current_order.size, self._current_order.extras)\n \n    def restore_order(self, memento: CoffeeOrder) -> None: \n        self._current_order = memento.get_state()\n \n# Abstract Memento class that stores the internal state of the originator.\nclass CoffeeOrderSnapshot(ABC): \n    @abstractmethod \n    def get_state(self) -> Any: \n        pass \n \n# Concrete memento class that extends the 'Memento' interface.\nclass CoffeeOrder(CoffeeOrderSnapshot): \n    def __init__(self, coffee_type: str, size: str, extras: List[str]) -> None: \n        self._coffee_type: str = coffee_type \n        self._size: str = size \n        self._extras: List[str] = extras \n \n    def get_state(self) -> Any: \n        return CoffeeOrder(self._coffee_type, self._size, self._extras) \n \n# Caretaker class that keeps track of multiple mementos.\nclass OrderHistory: \n    def __init__(self, barista: Barista) -> None: \n        self._barista: Barista = barista \n        self._mementos: List[CoffeeOrderSnapshot] = [] \n \n    def backup_order(self) -> None: \n        self._mementos.append(self._barista.save_order()) \n \n    def undo_order(self) -> None: \n        if not self._mementos: \n            return \n        memento = self._mementos.pop() \n        self._barista.restore_order(memento) \n \n# Client \ndef main() -> None: \n    barista = Barista(CoffeeOrder(\"Latte\", \"Medium\", [\"Extra Milk\", \"Sugar\"])) \n    order_history = OrderHistory(barista) \n \n    barista.take_order(\"Espresso\", \"Small\", [\"Extra Shot\"]) \n    order_history.backup_order() \n \n    print(f\"Current order: {barista._current_order.coffee_type} {barista._current_order.size} with {barista._current_order.extras}\") \n    # Current order: Espresso Small with ['Extra Shot'] \n \n    # Modify the current order \n    barista.take_order(\"Cappuccino\", \"Large\", [\"Extra Foam\"]) \n \n    print(f\"Modified order: {barista._current_order.coffee_type} {barista._current_order.size} with {barista._current_order.extras}\") \n    # Modified order: Cappuccino Large with ['Extra Foam'] \n \n    # Undo the last order \n    order_history.undo_order() \n \n    print(f\"Restored order: {barista._current_order.coffee_type} {barista._current_order.size} with {barista._current_order.extras}\") \n    # Restored order: Espresso Small with ['Extra Shot'] \n \nif __name__ == \"__main__\": \n    main()"
	},
	"State": {
		"scope": "python",
		"prefix": "!state",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Context}:",
			"  \"\"\"",
			"  Context class that maintains an instance of a ConcreteState subclass defining the current state.",
			"  \"\"\"",
			"  def __init__(self, state: ${2:State}) -> None:",
			"    # Initialize the '${1:Context}' object with the initial state.",
			"    self._state: ${2:State} = state",
			"",
			"  def ${3:request}(self) -> None:",
			"    # Delegate the request to the current state.",
			"    self._state.${4:handle}(self)",
			"",
			"  def ${5:change_state}(self, state: ${2:State}) -> None:",
			"    # Change the current state.",
			"    self._state = state",
			"",
			"class ${2:State}(ABC):",
			"  \"\"\"",
			"  Abstract base class for '${2:State}' objects.",
			"  Defines an interface for encapsulating the behavior associated with a particular state of the '${1:Context}' object.",
			"  \"\"\"",
			"  @abstractmethod",
			"  def ${4:handle}(self, context: ${1:Context}) -> None:",
			"    \"\"\"",
			"    Abstract method that must be implemented by concrete states.",
			"    \"\"\"",
			"    pass",
			"",
			"class ${3:ConcreteStateA}(${2:State}):",
			"  \"\"\"",
			"  Concrete state class that extends the '${2:State}' interface.",
			"  \"\"\"",
			"  def ${4:handle}(self, context: ${1:Context}) -> None:",
			"    # Handle the request and change the state of the context.",
			"    pass",
			"",
			"class ${5:ConcreteStateB}(${2:State}):",
			"  \"\"\"",
			"  Another concrete state class that extends the '${2:State}' interface.",
			"  \"\"\"",
			"  def ${4:handle}(self, context: ${1:Context}) -> None:",
			"    # Handle the request and change the state of the context.",
			"    pass"
		],
		"description": "Implements the State design pattern in Python.\nAllows an object to alter its behavior when its internal state changes.\nThe object will appear to change its class.\n\nExample:\nfrom abc import ABC, abstractmethod\nfrom typing import Any\n\n# Context\nclass CoffeeMachine:\n    def __init__(self, state: State) -> None:\n        self._state: State = state\n\n    def request(self) -> None:\n        self._state.handle(self)\n\n    def change_state(self, state: State) -> None:\n        self._state = state\n\n# Abstract State\nclass State(ABC):\n    @abstractmethod\n    def handle(self, context: CoffeeMachine) -> None:\n        pass\n\n# Concrete State A\nclass IdleState(State):\n    def handle(self, context: CoffeeMachine) -> None:\n        print(\"Coffee machine is idle. Ready for a new order.\")\n        context.change_state(AddingWaterState()) \\n\n# Concrete State B\nclass AddingWaterState(State):\n    def handle(self, context: CoffeeMachine) -> None:\n        print(\"Adding water to the coffee machine.\")\n        context.change_state(GrindingCoffeeBeansState())\n\n# Concrete State C\nclass GrindingCoffeeBeansState(State):\n    def handle(self, context: CoffeeMachine) -> None:\n        print(\"Grinding coffee beans.\")\n        context.change_state(BrewingCoffeeState())\n\n# Concrete State D\nclass BrewingCoffeeState(State):\n    def handle(self, context: CoffeeMachine) -> None:\n        print(\"Brewing coffee.\")\n        context.change_state(DispensingCoffeeState())\n\n# Concrete State E\nclass DispensingCoffeeState(State):\n    def handle(self, context: CoffeeMachine) -> None:\n        print(\"Dispensing coffee.\")\n        context.change_state(IdleState())\n\n# Client\ndef main() -> None:\n    coffee_machine = CoffeeMachine(IdleState())\n    coffee_machine.request() # Coffee machine is idle. Ready for a new order.\n    coffee_machine.request() # Adding water to the coffee machine.\n    coffee_machine.request() # Grinding coffee beans.\n    coffee_machine.request() # Brewing coffee.\n    coffee_machine.request() # Dispensing coffee.\n    coffee_machine.request() # Coffee machine is idle. Ready for a new order.\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Visitor": {
		"scope": "python",
		"prefix": "!visitor",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Visitor}(ABC):",
			"    \"\"\"",
			"    Abstract base class for visitors.",
			"    Declares a set of visit methods, one for each element type in the object structure.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def visit_${2:element_type_1}(self, element: ${2:ElementType1}) -> None:",
			"        \"\"\"",
			"        Visit method for ${2:ElementType1}.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def visit_${3:element_type_2}(self, element: ${3:ElementType2}) -> None:",
			"        \"\"\"",
			"        Visit method for ${3:ElementType2}.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${4:Element}(ABC):",
			"    \"\"\"",
			"    Abstract base class for elements in the object structure.",
			"    Declares an `accept` method that accepts a visitor.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def accept(self, visitor: ${1:Visitor}) -> None:",
			"        \"\"\"",
			"        Accept method for visitors.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${2:ElementType1}(${4:Element}):",
			"    \"\"\"",
			"    Concrete element class that extends the '${4:Element}' interface.",
			"    \"\"\"",
			"    def accept(self, visitor: ${1:Visitor}) -> None:",
			"        visitor.visit_${2:element_type_1}(self)",
			"",
			"class ${3:ElementType2}(${4:Element}):",
			"    \"\"\"",
			"    Another concrete element class that extends the '${4:Element}' interface.",
			"    \"\"\"",
			"    def accept(self, visitor: ${1:Visitor}) -> None:",
			"        visitor.visit_${3:element_type_2}(self)",
			"",
			"class ${5:ConcreteVisitor}(${1:Visitor}):",
			"    \"\"\"",
			"    Concrete visitor class that provides concrete implementations for visit methods.",
			"    \"\"\"",
			"    def visit_${2:element_type_1}(self, element: ${2:ElementType1}) -> None:",
			"		\"\"\"",
			"        Override the visit method for ${2:ElementType1}.",
			"        \"\"\"",
			"        pass",
			"",
			"    def visit_${3:element_type_2}(self, element: ${3:ElementType2}) -> None:",
			"		\"\"\"",
			"        Override the visit method for ${3:ElementType2}.",
			"        \"\"\"",
			"        pass",
		],
		"description": "Implements the Visitor design pattern in Python.\nAllows defining new operations without changing the classes of the elements on which they operate.\n\nExample:\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\n\n# Visitor\nclass Customer(ABC):\n    @abstractmethod\n    def visit_starbucks(self, shop: Starbucks) -> None:\n        pass\n\n    @abstractmethod\n    def visit_tim_hortons(self, shop: TimHortons) -> None:\n        pass\n\n# Element\nclass CoffeeShop(ABC):\n    @abstractmethod\n    def accept(self, visitor: Customer) -> None:\n        pass\n\n# Concrete Visitor\nclass CoffeeLover(Customer):\n    def visit_starbucks(self, shop: Starbucks) -> None:\n        print(\"Coffee lover is ordering a Latte at Starbucks.\")\n\n    def visit_tim_hortons(self, shop: TimHortons) -> None:\n        print(\"Coffee lover is ordering a Double Double at Tim Hortons.\")\n\n# Concrete Element\nclass Starbucks(CoffeeShop):\n    def accept(self, visitor: Customer) -> None:\n        visitor.visit_starbucks(self)\n\n# Concrete Element\nclass TimHortons(CoffeeShop):\n    def accept(self, visitor: Customer) -> None:\n        visitor.visit_tim_hortons(self)\n\n# Client\ndef main() -> None:\n    starbucks = Starbucks()\n    tim_hortons = TimHortons()\n\n    coffee_lover = CoffeeLover()\n\n    starbucks.accept(coffee_lover) # Coffee lover is ordering a Latte at Starbucks.\n    tim_hortons.accept(coffee_lover) # Coffee lover is ordering a Double Double at Tim Hortons.\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Composite": {
		"scope": "python",
		"prefix": "!composite",
		"body": [
			"from abc import ABC, abstractmethod",
			"from typing import List",
			"",
			"class ${1:Component}(ABC):",
			"    \"\"\"",
			"    Abstract base class for components.",
			"    Declares the interface for objects in the composition.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract method representing the '${2:operation}' to be performed.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:Leaf}(${1:Component}):",
			"    \"\"\"",
			"    Leaf class that represents individual objects in the composition.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Implement '${2:operation}' for the leaf.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${4:Composite}(${1:Component}):",
			"    \"\"\"",
			"    Composite class that contains '${3:Leaf}' and '${4:Composite}' components.",
			"    Implements the operations declared by the Component interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self._children: List[${1:Component}] = []",
			"",
			"    def add(self, component: ${1:Component}) -> None:",
			"        \"\"\"",
			"        Add a component to the composite.",
			"        \"\"\"",
			"        self._children.append(component)",
			"",
			"    def remove(self, component: ${1:Component}) -> None:",
			"        \"\"\"",
			"        Remove a component from the composite.",
			"        \"\"\"",
			"        self._children.remove(component)",
			"",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Implement '${2:operation}' for the composite.",
			"        \"\"\"",
			"        for child in self._children:",
			"            child.${2:operation}()"
		],
		"description": "Implements the Composite design pattern in Python.\nComposes objects into tree structures to represent part-whole hierarchies.\nClients can treat individual objects and compositions of objects uniformly.\n\nExample:\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\n# Component\nclass CoffeeComponent(ABC):\n    @abstractmethod\n    def show(self) -> None:\n        pass\n\n# Leaf\nclass CoffeeLeaf(CoffeeComponent):\n    def __init__(self, name: str) -> None:\n        self._name: str = name\n\n    def show(self) -> None:\n        print(f\"Adding {self._name} to the coffee.\")\n\n# Composite\nclass CoffeeBlend(CoffeeComponent):\n    def __init__(self, name: str) -> None:\n        self._name: str = name\n        self._ingredients: List[CoffeeComponent] = []\n\n    def add(self, ingredient: CoffeeComponent) -> None:\n        self._ingredients.append(ingredient)\n\n    def remove(self, ingredient: CoffeeComponent) -> None:\n        self._ingredients.remove(ingredient)\n\n    def show(self) -> None:\n        print(f\"Making {self._name} blend.\")\n        for ingredient in self._ingredients:\n            ingredient.show()\n\n# Client\ndef main() -> None:\n    # Create a leaf\n    espresso = CoffeeLeaf(\"Espresso\")\n    milk = CoffeeLeaf(\"Milk\")\n    sugar = CoffeeLeaf(\"Sugar\")\n\n    latte = CoffeeBlend(\"Latte\")\n    latte.add(espresso)\n    latte.add(milk)\n\n    sweet_latte = CoffeeBlend(\"Sweet Latte\")\n    sweet_latte.add(latte)\n    sweet_latte.add(sugar)\n\n    latte.show()\n    # Making Latte blend. Adding Espresso to the coffee. Adding Milk to the coffee.\n\n    sweet_latte.show()\n    # Making Sweet Latte blend. Making Latte blend. Adding Espresso to the coffee. Adding Milk to the coffee. Adding Sugar to the coffee.\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Iterator": {
		"prefix": "!iterator",
		"body": [
			"from collections.abc import Iterable, Iterator",
			"from typing import Any, List",
			"",
			"class ${1:ConcreteIterator}(${2:Iterator}):",
			"    \"\"\"",
			"    Concrete iterator class that implements the Iterator interface.",
			"    \"\"\"",
			"    def __init__(self, collection: ${3:Iterable}) -> None:",
			"        \"\"\"",
			"        Initialize the iterator with the given collection.",
			"        \"\"\"",
			"        self._collection: ${3:Iterable} = collection",
			"        self._position: int = 0",
			"",
			"    def __iter__(self) -> ${2:Iterator}:",
			"        \"\"\"",
			"        Return the iterator object.",
			"        \"\"\"",
			"        return self",
			"",
			"    def __next__(self) -> ${4:Any}:",
			"        \"\"\"",
			"        Return the next element from the collection.",
			"        \"\"\"",
			"        try:",
			"            value = self._collection[self._position]",
			"            self._position += 1",
			"            return value",
			"        except IndexError:",
			"            raise StopIteration",
			"",
			"class ${5:ConcreteIterable}(${3:Iterable}):",
			"    \"\"\"",
			"    Concrete iterable class that implements the Iterable interface.",
			"    \"\"\"",
			"    def __init__(self, collection: List[${4:Any}]) -> None:",
			"        \"\"\"",
			"        Initialize the iterable with the given list.",
			"        \"\"\"",
			"        self._collection: List[${4:Any}] = collection",
			"",
			"    def __iter__(self) -> ${1:ConcreteIterator}:",
			"        \"\"\"",
			"        Return the iterator object for the iterable.",
			"        \"\"\"",
			"        return ${1:ConcreteIterator}(self._collection)"
		],
		"description": "Implements the Iterator design pattern in Python.\nProvides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.\n\nExample:\nfrom collections.abc import Iterable, Iterator\nfrom typing import Any, List\n\n# Iterator\nclass MenuIterator(Iterator):\n    def __init__(self, menu_items: Iterable) -> None:\n        self._menu_items: Iterable = menu_items\n        self._position: int = 0\n\n    def __iter__(self) -> Iterator:\n        return self\n\n    def __next__(self) -> Any:\n        try:\n            value = self._menu_items[self._position]\n            self._position += 1\n            return value\n        except IndexError:\n            raise StopIteration\n\n# Iterable\nclass Menu(Iterable):\n    def __init__(self, menu_items: List[str]) -> None:\n        self._menu_items: List[str] = menu_items\n\n    def __iter__(self) -> Iterator:\n        return MenuIterator(self._menu_items)\n\n# Client\ndef main() -> None:\n    items = [\"Capuccino\", \"Espresso\", \"Latte\", \"Mocha\"]\n    menu = Menu(items)\n\n    for item in menu:\n        print(item)\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Mediator": {
		"scope": "python",
		"prefix": "!mediator",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"from typing import Any, List",
			"",
			"class ${1:Mediator}(ABC):",
			"    \"\"\"",
			"    Mediator interface that defines the communication protocol between colleagues.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:register_colleague}(self, colleague: ${6:Colleague}) -> None:",
			"        \"\"\"",
			"        Register a colleague with the mediator.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${3:send}(self, sender: ${6:Colleague}, event: Any) -> None:",
			"        \"\"\"",
			"        Send an event from a colleague to other colleagues through the mediator.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${6:Colleague}(ABC):",
			"    \"\"\"",
			"    Colleague class that communicates through a mediator.",
			"    \"\"\"",
			"    def __init__(self, mediator: ${1:Mediator}) -> None:",
			"        \"\"\"",
			"        Initialize the colleague with a reference to the mediator.",
			"        \"\"\"",
			"        self._mediator: ${1:Mediator} = mediator",
			"",
			"    @abstractmethod",
			"    def ${3:send}(self, event: Any) -> None:",
			"        \"\"\"",
			"        Send an event to other colleagues through the mediator.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${7:receive}(self, event: Any) -> None:",
			"        \"\"\"",
			"        Handle an incoming event from the mediator.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${8:ConcreteMediator}(${1:Mediator}):",
			"    \"\"\"",
			"    Concrete mediator class that implements the Mediator interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        \"\"\"",
			"        Initialize the concrete mediator.",
			"        \"\"\"",
			"        self._colleagues: List[${6:Colleague}] = []",
			"",
			"    def ${2:register_colleague}(self, colleague: ${6:Colleague}) -> None:",
			"        \"\"\"",
			"        Register a colleague with the mediator.",
			"        \"\"\"",
			"        self._colleagues.append(colleague)",
			"",
			"    def ${3:send}(self, sender: ${6:Colleague}, event: Any) -> None:",
			"        \"\"\"",
			"        Broadcast an event from a sender to other colleagues.",
			"        \"\"\"",
			"        for colleague in self._colleagues:",
			"            if colleague != sender:",
			"                colleague.${7:receive}(event)",
			"",
			"class ${8:ConcreteColleague}(${6:Colleague}):",
			"    \"\"\"",
			"    Concrete colleague class that implements the Colleague interface.",
			"    \"\"\"",
			"    def ${7:receive}(self, event: Any) -> None:",
			"        \"\"\"",
			"        Handle an incoming event from the mediator.",
			"        \"\"\"",
			"        pass"
		],
		"description": "Implements the Mediator design pattern in Python.\nDefines an object that centralizes communication between a set of objects, allowing them to communicate without being directly connected.\n\nExample:\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\nfrom typing import Any, List\n\n# Mediator\nclass Mediator(ABC):\n    @abstractmethod\n    def register_colleague(self, colleague: Colleague) -> None:\n        pass\n\n    @abstractmethod\n    def send(self, sender: Colleague, event: Any) -> None:\n        pass\n\n# Colleague\nclass Colleague(ABC):\n    def __init__(self, mediator: Mediator) -> None:\n        self._mediator: Mediator = mediator\n\n    @abstractmethod\n    def send(self, event: Any) -> None:\n        pass\n\n    @abstractmethod\n    def receive(self, event: Any) -> None:\n        pass\n\n# Concrete Mediator\nclass Waiter(Mediator):\n    def __init__(self) -> None:\n        self._colleagues: List[Colleague] = []\n\n    def register_colleague(self, colleague: Colleague) -> None:\n        self._colleagues.append(colleague)\n\n    def send(self, sender: Colleague, event: Any) -> None:\n        for colleague in self._colleagues:\n            if colleague != sender:\n                colleague.receive(event)\n\n# Concrete Colleague\nclass Barista(Colleague):\n    def send(self, event: Any) -> None:\n        self._mediator.send(self, event)\n\n    def receive(self, event: Any) -> None:\n        print(f\"Barista received: {event}\")\n\n# Concrete Colleague\nclass Customer(Colleague):\n    def send(self, event: Any) -> None:\n        self._mediator.send(self, event)\n\n    def receive(self, event: Any) -> None:\n        print(f\"Customer received: {event}\")\n\n# Client\ndef main() -> None:\n    waiter = Waiter()\n\n    barista = Barista(waiter)\n    customer = Customer(waiter)\n\n    waiter.register_colleague(barista)\n    waiter.register_colleague(customer)\n\n    barista.send(\"Order for a Latte.\")\n    # Customer received: Order for a Latte.\n\n    customer.send(\"Thank you!\")\n    # Barista received: Thank you!\n\nif __name__ == \"__main__\":\n    main()"
	}
}