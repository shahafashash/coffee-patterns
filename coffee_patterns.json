{
	"Factory Pattern": {
		"scope": "python",
		"prefix": "factory",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Product}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Product}' objects.",
			"    It declares the interface for the type of objects that the factory method creates.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract ${2:operation} method. Needs to be implemented by concrete '${1:Product}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:ConcreteProductA}(${1:Product}):",
			"    \"\"\"",
			"    Concrete product class that implements the '${1:Product}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:ConcreteProductB}(${1:Product}):",
			"    \"\"\"",
			"    Another concrete product class that implements the '${1:Product}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${5:Creator}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${5:Creator}' objects.",
			"    It declares the factory method that is supposed to return an object of type '${1:Product}'.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${6:factory_method}(self) -> ${1:Product}:",
			"        pass",
			"",
			"class ${7:ConcreteCreatorA}(${5:Creator}):",
			"    \"\"\"",
			"    Concrete creator class that implements the '${5:Creator}' interface.",
			"    It overrides the factory method to create a '${3:ConcreteProductA}' instance.",
			"    \"\"\"",
			"    def ${6:factory_method}(self) -> ${3:ConcreteProductA}:",
			"        return ${3:ConcreteProductA}()",
			"",
			"class ${8:ConcreteCreatorB}(${5:Creator}):",
			"    \"\"\"",
			"    Another concrete creator class that implements the '${5:Creator}' interface.",
			"    It overrides the factory method to create a '${4:ConcreteProductB}' instance.",
			"    \"\"\"",
			"    def ${6:factory_method}(self) -> ${4:ConcreteProductB}:",
			"        return ${4:ConcreteProductB}()",
			""
		],
		"description": "Implements the Factory design pattern in Python.\n\nDefines:\n- An abstract class for products\n- Concrete product classes that implement the interface\n- An abstract creator class with a factory method\n- Concrete creator classes that override the factory method to create specific product instances.\n\nExample:\n```python\nfrom abc import ABC, abstractmethod\n\n# Product\nclass Coffee(ABC):\n    @abstractmethod\n    def brew(self) -> None:\n        pass\n\n# ConcreteProduct\nclass Espresso(Coffee):\n    def brew(self) -> None:\n        print(\"Brewing Espresso\")\n\n# ConcreteProduct\nclass Latte(Coffee):\n    def brew(self) -> None:\n        print(\"Brewing Latte\")\n\n# Creator\nclass CoffeeMachine(ABC):\n    @abstractmethod\n    def create_coffee(self) -> Coffee:\n        pass\n\n# ConcreteCreator\nclass EspressoMachine(CoffeeMachine):\n    def create_coffee(self) -> Espresso:\n        return Espresso()\n\n# ConcreteCreator\nclass LatteMachine(CoffeeMachine):\n    def create_coffee(self) -> Latte:\n        return Latte()\n\n# Client\ndef main() -> None:\n    espresso_machine = EspressoMachine()\n    latte_machine = LatteMachine()\n\n    espresso_machine.create_coffee().brew()\n    latte_machine.create_coffee().brew()\n\nif __name__ == \"__main__\":\n    main()```"
	},
	"Abstract Factory": {
		"scope": "python",
		"prefix": "abstract_factory",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:AbstractProductA}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:AbstractProductA}' objects.",
			"    It declares the interface for the type of objects that the factory method creates.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${2:operation}' method. Needs to be implemented by concrete '${1:AbstractProductA}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:ConcreteProductA1}(${1:AbstractProductA}):",
			"    \"\"\"",
			"    Concrete product class that implements the '${1:AbstractProductA}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:ConcreteProductA2}(${1:AbstractProductA}):",
			"    \"\"\"",
			"    Another concrete product class that implements the '${1:AbstractProductA}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${5:AbstractProductB}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${5:AbstractProductB}' objects.",
			"    It declares the interface for the type of objects that the factory method creates.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${6:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${6:operation}' method. Needs to be implemented by concrete '${5:AbstractProductB}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteProductB1}(${5:AbstractProductB}):",
			"    \"\"\"",
			"    Concrete product class that implements the '${5:AbstractProductB}' interface.",
			"    \"\"\"",
			"    def ${6:operation}(self) -> None:",
			"        pass",
			"",
			"class ${8:ConcreteProductB2}(${5:AbstractProductB}):",
			"    \"\"\"",
			"    Another concrete product class that implements the '${5:AbstractProductB}' interface.",
			"    \"\"\"",
			"    def ${6:operation}(self) -> None:",
			"        pass",
			"",
			"class ${9:AbstractFactory}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:AbstractProductA}' and '${5:AbstractProductB}' objects.",
			"    It declares the factory method that is supposed to return an object of type '${1:AbstractProductA}' or '${5:AbstractProductB}'.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${10:factory_method_a}(self) -> ${1:AbstractProductA}:",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${11:factory_method_b}(self) -> ${5:AbstractProductB}:",
			"        pass",
			"",
			"class ${12:ConcreteFactory1}(${9:AbstractFactory}):",
			"    \"\"\"",
			"    Concrete factory class that implements the '${9:AbstractFactory}' interface.",
			"    It overrides the factory methods to create '${3:ConcreteProductA1}' and '${7:ConcreteProductB1}' instances.",
			"    \"\"\"",
			"    def ${10:factory_method_a}(self) -> ${3:ConcreteProductA1}:",
			"        return ${3:ConcreteProductA1}()",
			"",
			"    def ${11:factory_method_b}(self) -> ${7:ConcreteProductB1}:",
			"        return ${7:ConcreteProductB1}()",
			"",
			"class ${13:ConcreteFactory2}(${9:AbstractFactory}):",
			"    \"\"\"",
			"    Another concrete factory class that implements the '${9:AbstractFactory}' interface.",
			"    It overrides the factory methods to create '${4:ConcreteProductA2}' and '${8:ConcreteProductB2}' instances.",
			"    \"\"\"",
			"    def ${10:factory_method_a}(self) -> ${4:ConcreteProductA2}:",
			"        return ${4:ConcreteProductA2}()",
			"",
			"    def ${11:factory_method_b}(self) -> ${8:ConcreteProductB2}:",
			"        return ${8:ConcreteProductB2}()",
			""
		],
		"description": "Creates an Abstract Factory design pattern structure in Python.\nDefines:\n- Abstract product classes\n- Concrete product classes\n- An abstract factory class with factory methods for each product\n- Concrete factory classes that override the factory methods to produce specific product instances.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# AbstractProductA\nclass CoffeeBean(ABC):\n    @abstractmethod\n    def grind(self) -> None:\n        pass\n\n# ConcreteProductA\nclass ArabicaBean(CoffeeBean):\n    def grind(self) -> None:\n        print(\"Grinding Arabica Beans\")\n\n# ConcreteProductA\nclass RobustaBean(CoffeeBean):\n    def grind(self) -> None:\n        print(\"Grinding Robusta Beans\")\n\n# AbstractProductB\nclass Milk(ABC):\n    @abstractmethod\n    def froth(self) -> None:\n        pass\n\n# ConcreteProductB\nclass WholeMilk(Milk):\n    def froth(self) -> None:\n        print(\"Frothing Whole Milk\")\n\n# ConcreteProductB\nclass AlmondMilk(Milk):\n    def froth(self) -> None:\n        print(\"Frothing Almond Milk\")\n\n# AbstractFactory\nclass CoffeeFactory(ABC):\n    @abstractmethod\n    def create_coffee_bean(self) -> CoffeeBean:\n        pass\n\n    @abstractmethod\n    def create_milk(self) -> Milk:\n        pass\n\n# ConcreteFactory1\nclass ArabicaLatteFactory(CoffeeFactory):\n    def create_coffee_bean(self) -> CoffeeBean:\n        return ArabicaBean()\n\n    def create_milk(self) -> Milk:\n        return WholeMilk()\n\n# ConcreteFactory2\nclass RobustaAlmondLatteFactory(CoffeeFactory):\n    def create_coffee_bean(self) -> CoffeeBean:\n        return RobustaBean()\n\n    def create_milk(self) -> Milk:\n        return AlmondMilk()\n\n# Client\ndef main() -> None:\n    arabica_latte_factory = ArabicaLatteFactory()\n    robusta_almond_latte_factory = RobustaAlmondLatteFactory()\n\n    arabica_latte_factory.create_coffee_bean().grind()\n    arabica_latte_factory.create_milk().froth()\n\n    robusta_almond_latte_factory.create_coffee_bean().grind()\n    robusta_almond_latte_factory.create_milk().froth()\n\nif __name__ == \"__main__\":\n    main()"
	},

	"Builder": {
		"scope": "python",
		"prefix": "builder",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Product}:",
			"    \"\"\"",
			"    Represents the complex object under construction.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        \"\"\"",
			"        Defines the object to be built.",
			"        \"\"\"",
			"        pass",
			"",
			"    def add_${2:part1}(self) -> None:",
			"        pass",
			"",
			"    def add_${3:part2}(self) -> None:",
			"        pass",
			"",
			"class ${4:Builder}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${4:Builder}' objects.",
			"    It declares the interface for creating parts of a complex object.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def build_${2:part1}(self) -> ${4:Builder}:",
			"        \"\"\"",
			"        Abstract build_${2:part1} method. Needs to be implemented by concrete '${4:Builder}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def build_${3:part2}(self) -> ${4:Builder}:",
			"        \"\"\"",
			"        Abstract build_${3:part2} method. Needs to be implemented by concrete '${4:Builder}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteBuilder}(${4:Builder}):",
			"    \"\"\"",
			"    Concrete builder class that implements the '${4:Builder}' interface.",
			"    It constructs and assembles parts of the product by implementing the builder interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self.reset()",
			"",
			"    def reset(self) -> None:",
			"        self._product = ${1:Product}()",
			"",
			"    @property",
			"    def product(self) -> ${1:Product}:",
			"        product = self._product",
			"        self.reset()",
			"        return product",
			"",
			"    def build_${2:part1}(self) -> ${7:ConcreteBuilder}:",
			"        self._product.add_${2:part1}()",
			"        return self",
			"",
			"    def build_${3:part2}(self) -> ${7:ConcreteBuilder}:",
			"        self._product.add_${3:part2}()",
			"        return self",
			""
		],
		"description": "Constructs a Builder design pattern structure in Python.\nDefines:\n- A product class with complex construction\n- An abstract builder class with methods for building parts of the product\n- A concrete builder class that implements the builder interface.\nThis pattern enables the step-by-step construction of a complex object.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Product\nclass Coffee:\n    def __init__(self) -> None:\n        self.parts = []\n\n    def add_beans(self) -> None:\n        self.parts.append(\"Coffee Beans\")\n\n    def add_water(self) -> None:\n        self.parts.append(\"Water\")\n\n# Builder\nclass CoffeeBuilder(ABC):\n    @abstractmethod\n    def build_beans(self) -> None:\n        pass\n\n    @abstractmethod\n    def build_water(self) -> None:\n        pass\n\n    @abstractmethod\n    def get_coffee(self) -> Coffee:\n        pass\n\n# ConcreteBuilder\nclass LatteBuilder(CoffeeBuilder):\n    def __init__(self) -> None:\n        self._coffee = Coffee()\n\n    def build_beans(self) -> None:\n        self._coffee.add_beans()\n\n    def build_water(self) -> None:\n        self._coffee.add_water()\n\n    def get_coffee(self) -> Coffee:\n        return self._coffee\n\n# Client\ndef main() -> None:\n    latte_builder = LatteBuilder()\n    latte_builder.build_beans()\n    latte_builder.build_water()\n    latte = latte_builder.get_coffee()\n\nif __name__ == \"__main__\":\n    main()"
	},

	"Builder With Director": {
		"scope": "python",
		"prefix": "builder_director",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Product}:",
			"    \"\"\"",
			"    Represents the complex object under construction.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        \"\"\"",
			"        Defines the object to be built.",
			"        \"\"\"",
			"        pass",
			"",
			"    def add_${2:part1}(self) -> None:",
			"        pass",
			"",
			"    def add_${3:part2}(self) -> None:",
			"        pass",
			"",
			"class ${4:Builder}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${4:Builder}' objects.",
			"    It declares the interface for creating parts of a complex object.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def build_${2:part1}(self) -> ${4:Builder}:",
			"        \"\"\"",
			"        Abstract build_${2:part1} method. Needs to be implemented by concrete '${4:Builder}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def build_${3:part2}(self) -> ${4:Builder}:",
			"        \"\"\"",
			"        Abstract build_${3:part2} method. Needs to be implemented by concrete '${4:Builder}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteBuilder}(${4:Builder}):",
			"    \"\"\"",
			"    Concrete builder class that implements the '${4:Builder}' interface.",
			"    It constructs and assembles parts of the product by implementing the builder interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self.reset()",
			"",
			"    def reset(self) -> None:",
			"        self._product = ${1:Product}()",
			"",
			"    @property",
			"    def product(self) -> ${1:Product}:",
			"        product = self._product",
			"        self.reset()",
			"        return product",
			"",
			"    def build_${2:part1}(self) -> ${7:ConcreteBuilder}:",
			"        self._product.add_${2:part1}()",
			"        return self",
			"",
			"    def build_${3:part2}(self) -> ${7:ConcreteBuilder}:",
			"        self._product.add_${3:part2}()",
			"        return self",
			"",
			"class ${8:Director}:",
			"    \"\"\"",
			"    Director class that constructs a product using a builder.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self._builder = None",
			"",
			"    @property",
			"    def builder(self) -> ${7:ConcreteBuilder}:",
			"        return self._builder",
			"",
			"    @builder.setter",
			"    def builder(self, builder: ${4:Builder}) -> None:",
			"        self._builder = builder",
			"",
			"    def build_${9:product}(self) -> None:",
			"        self.builder \\",
			"            .build_${2:part1}() \\",
			"            .build_${3:part2}()",
			"",
			"    def get_product(self) -> ${1:Product}:",
			"        return self.builder.product",
			""
		],
		"description": "Creates a Builder design pattern structure with a Director in Python. Combines the Builder and Director patterns to facilitate the construction of a complex object. The Director class orchestrates the building process using a builder, ensuring a consistent construction sequence.\n\nExample:\nfrom abc import ABC, abstractmethod\n\n# Product\nclass Coffee:\n    def __init__(self) -> None:\n        self.parts = []\n\n    def add_beans(self) -> None:\n        self.parts.append(\"Coffee Beans\")\n\n    def add_water(self) -> None:\n        self.parts.append(\"Water\")\n\n# Builder\nclass CoffeeBuilder(ABC):\n    @abstractmethod\n    def build_beans(self) -> None:\n        pass\n\n    @abstractmethod\n    def build_water(self) -> None:\n        pass\n\n    @abstractmethod\n    def get_coffee(self) -> Coffee:\n        pass\n\n# ConcreteBuilder\nclass LatteBuilder(CoffeeBuilder):\n    def __init__(self) -> None:\n        self._coffee = Coffee()\n\n    def build_beans(self) -> None:\n        self._coffee.add_beans()\n\n    def build_water(self) -> None:\n        self._coffee.add_water()\n\n    def get_coffee(self) -> Coffee:\n        return self._coffee\n\n# Director\nclass Barista:\n    def __init__(self) -> None:\n        self._builder = None\n\n    @property\n    def builder(self) -> CoffeeBuilder:\n        return self._builder\n\n    @builder.setter\n    def builder(self, builder: CoffeeBuilder) -> None:\n        self._builder = builder\n\n    def make_coffee(self) -> None:\n        self.builder /\n            .build_beans() /\n            .build_water()\n\n    def get_coffee(self) -> Coffee:\n        return self.builder.get_coffee()\n\n# Client\ndef main() -> None:\n    barista = Barista()\n    barista.builder = LatteBuilder()\n    barista.make_coffee()\n    latte = barista.get_coffee()\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Singleton": {
		"scope": "python",
		"prefix": "singleton",
		"body": [
			"from typing import Any, Dict",
			"",
			"class ${1:SingletonMeta}(type):",
			"    \"\"\"",
			"    Metaclass implementing the Singleton design pattern.",
			"    \"\"\"",
			"    _instances: Dict[Type['${1:SingletonMeta}'], Any] = {}",
			"",
			"    def __call__(cls, *args, **kwargs):",
			"        \"\"\"",
			"        Override the default behavior of creating instances.",
			"        Ensures that only one instance of the class exists.",
			"        \"\"\"",
			"        if cls not in cls._instances:",
			"            cls._instances[cls] = super().__call__(*args, **kwargs)",
			"        return cls._instances[cls]",
			"",
			"class ${2:Singleton}(metaclass=${1:SingletonMeta}):",
			"    \"\"\"",
			"    Singleton class implementing the Singleton design pattern.",
			"    \"\"\"",
			"    def ${3:operation}(self) -> None:",
			"        \"\"\"",
			"        Placeholder for the operation that the Singleton performs.",
			"        Replace this with the actual functionality of your Singleton.",
			"        \"\"\"",
			"        pass",
			""
		],
		"description": "Implements the Singleton design pattern in Python.\nEnsures a class has only one instance and provides a global point of access to it.\nThis pattern involves a single class that is responsible for creating its own unique instance and ensuring that only a single instance exists.\n\nExample:\nclass SingletonMeta(type):\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n# Singleton\nclass InfiniteCoffeeCup(metaclass=SingletonMeta):\n    def __init__(self) -> None:\n        self.coffee = float('inf')  # Infinite coffee\n\n    def drink(self, amount: float) -> None:\n        self.coffee -= amount\n\n    def coffee_left(self) -> float:\n        return self.coffee\n\n# Client\ndef main() -> None:\n    cup1 = InfiniteCoffeeCup()\n    cup2 = InfiniteCoffeeCup()\n\n    cup1.drink(0.5)\n    cup2.drink(0.25)\n\n    print(cup1.coffee_left())\n    print(cup2.coffee_left())\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Singleton Thread-Safe ": {
		"scope": "python",
		"prefix": "singleton_thread_safe",
		"body": [
			"from typing import Any, Dict, Type",
			"from threading import Lock",
			"",
			"class ${1:SingletonMeta}(type):",
			"    \"\"\"",
			"    Metaclass implementing the Singleton design pattern.",
			"    \"\"\"",
			"    _instances: Dict[Type['${1:SingletonMeta}'], Any] = {}",
			"    _lock: Lock = Lock()",
			"",
			"    def __call__(cls, *args, **kwargs):",
			"        \"\"\"",
			"        Override the default behavior of creating instances.",
			"        Ensures that only one instance of the class exists.",
			"        \"\"\"",
			"        with cls._lock:",
			"            if cls not in cls._instances:",
			"                cls._instances[cls] = super().__call__(*args, **kwargs)",
			"        return cls._instances[cls]",
			"",
			"class ${2:Singleton}(metaclass=${1:SingletonMeta}):",
			"    \"\"\"",
			"    Singleton class implementing the Singleton design pattern.",
			"    \"\"\"",
			"    def ${3:operation}(self) -> None:",
			"        \"\"\"",
			"        Placeholder for the operation that the Singleton performs.",
			"        Replace this with the actual functionality of your Singleton.",
			"        \"\"\"",
			"        pass",
			""
		],
		"description": "Implements the Thread-Safe Singleton design pattern in Python.\nEnsures that a class has only one instance and provides a global point of access to it, while being thread-safe.\nThis pattern involves using a lock or other mechanism to synchronize access to the singleton instance, preventing multiple threads from creating multiple instances simultaneously.\n\nExample:\nfrom typing import Any, Dict, Type\nfrom threading import Lock, Thread\n\nclass SingletonMeta(type):\n    _instances = {}\n    _lock = Lock()\n\n    def __call__(cls, *args, **kwargs):\n        with cls._lock:\n            if cls not in cls._instances:\n                cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n# Singleton\nclass CoffeeShop(metaclass=SingletonMeta):\n    def __init__(self, name: str, owner: str) -> None:\n        self.name = name\n        self.owner = owner\n\n# Client\ndef main() -> None:\n    def create_coffee_shop(name: str, owner: str) -> None:\n        coffee_shop = CoffeeShop(name, owner)\n        print(f\"Created coffee shop {coffee_shop.name} owned by {coffee_shop.owner}\")\n\n    starbucks = Thread(target=create_coffee_shop, args=(\"Starbucks\", \"Howard Schultz\"))\n    dunkin = Thread(target=create_coffee_shop, args=(\"Dunkin\", \"William Rosenberg\"))\n\n    starbucks.start()\n    dunkin.start()\n    starbucks.join()\n    dunkin.join()\n\nif __name__ == \"__main__\":\n    main()"
	},
	"Prototype": {
		"scope": "python",
		"prefix": "prototype",
		"body": [
			"from __future__ import annotations",
			"from typing import Any, Dict",
			"import copy",
			"",
			"class ${1:Prototype}:",
			"    \"\"\"",
			"    Prototype class implementing the Prototype design pattern.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        \"\"\"",
			"        Initialize the Prototype object.",
			"        \"\"\"",
			"        pass",
			"",
			"    def __copy__(self) -> ${1:Prototype}:",
			"        \"\"\"",
			"        Create a shallow copy of the object.",
			"        \"\"\"",
			"        # Perform a shallow copy of the object's attributes.",
			"        new = self.__class__()",
			"        new.__dict__.update(self.__dict__)",
			"        return new",
			"",
			"    def __deepcopy__(self, memo: Dict[int, Any]=None) -> ${1:Prototype}:",
			"        \"\"\"",
			"        Create a deep copy of the object.",
			"        \"\"\"",
			"        if memo is None:",
			"            memo = {}",
			"",
			"        # Perform a deep copy of the object's attributes.",
			"        new = self.__class__()",
			"        new.__dict__ = copy.deepcopy(self.__dict__, memo)",
			"        return new",
			""
		],
		"description": "Implements the Prototype design pattern in Python. Introduces a prototype class that defines the object to be cloned. Offers methods for creating shallow and deep copies of the object, allowing flexible instantiation of similar objects without specifying their classes."
	},
	"Adapter with Inheritance": {
		"scope": "python",
		"prefix": "adapter_inheritance",
		"body": [
			"class ${2:Adaptee}:",
			"    \"\"\"",
			"    Adaptee class with functionality to be adapted.",
			"    \"\"\"",
			"    def ${4:adaptee_method}(self) -> None:",
			"        # Adaptee's method implementation",
			"        pass",
			"",
			"class ${1:Adapter}(${2:Adaptee}):",
			"    \"\"\"",
			"    Adapter class that inherits from the Adaptee class.",
			"    Implements the target interface while reusing functionality from ${2:Adaptee}.",
			"    \"\"\"",
			"    def ${3:target_method}(self) -> None:",
			"        # Implement the target interface by delegating to ${2:Adaptee}'s method",
			"        self.${4:adaptee_method}()"
		],
		"description": "Implements the Adapter design pattern using inheritance. Adapts an Adaptee class to the target interface by inheriting from the Adaptee class and implementing the target interface."
	},
	"Adapter with Object Composition": {
		"scope": "python",
		"prefix": "adapter_composition",
		"body": [
			"class ${2:Adaptee}:",
			"    \"\"\"",
			"    Adaptee class with functionality to be adapted.",
			"    \"\"\"",
			"    def ${4:adaptee_method}(self) -> None:",
			"        # Adaptee's method implementation",
			"        pass",
			"",
			"class ${1:Adapter}:",
			"    \"\"\"",
			"    Adapter class that uses object composition to adapt an Adaptee class.",
			"    Implements the target interface by composing an instance of ${2:Adaptee}.",
			"    \"\"\"",
			"    def __init__(self, adaptee: ${2:Adaptee}):",
			"        self.adaptee: ${2:Adaptee} = adaptee",
			"",
			"    def ${3:target_method}(self) -> None:",
			"        # Implement the target interface by delegating to ${2:Adaptee}'s method",
			"        self.adaptee.${4:adaptee_method}()"
		],
		"description": "Implements the Adapter design pattern using object composition. Adapts an Adaptee class to the target interface by composing an instance of Adaptee within the Adapter class and implementing the target interface."
	},
	"Bridge": {
		"scope": "python",
		"prefix": "bridge",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Abstraction}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Abstraction}' objects.",
			"    It defines the abstraction's interface and maintains a reference to an object of type '${2:Implementor}'.",
			"    \"\"\"",
			"    def __init__(self, ${2:implementor}: ${3:Implementor}) -> None:",
			"        self.${2:implementor}: ${3:Implementor} = ${2:implementor}",
			"",
			"    @abstractmethod",
			"    def ${4:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${4:operation}' method. Needs to be implemented by concrete '${1:Abstraction}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${5:RefinedAbstractionA}(${1:Abstraction}):",
			"    \"\"\"",
			"    Refined abstraction class that extends the interface defined by '${1:Abstraction}'.",
			"    \"\"\"",
			"    def ${4:operation}(self) -> None:",
			"        # Delegate the implementation to the '${2:Implementor}' object",
			"        self.${2:implementor}.${4:operation}()",
			"",
			"class ${6:RefinedAbstractionB}(${1:Abstraction}):",
			"    \"\"\"",
			"    Another refined abstraction class that extends the interface defined by '${1:Abstraction}'.",
			"    \"\"\"",
			"    def ${4:operation}(self) -> None:",
			"        # Delegate the implementation to the '${2:Implementor}' object",
			"        self.${2:implementor}.${4:operation}()",
			"",
			"class ${2:Implementor}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${2:Implementor}' objects.",
			"    It defines the interface for implementation classes.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${4:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${4:operation}' method. Needs to be implemented by concrete '${2:Implementor}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${7:ConcreteImplementorA}(${2:Implementor}):",
			"    \"\"\"",
			"    Concrete implementation class that implements the '${2:Implementor}' interface.",
			"    \"\"\"",
			"    def ${4:operation}(self) -> None:",
			"        pass",
			"",
			"class ${8:ConcreteImplementorB}(${2:Implementor}):",
			"    \"\"\"",
			"    Another concrete implementation class that implements the '${2:Implementor}' interface.",
			"    \"\"\"",
			"    def ${4:operation}(self) -> None:",
			"        pass",
			""
		],
		"description": "Implements the Bridge design pattern in Python. Defines an abstract class for the abstraction, concrete classes that extend the abstraction, an abstract class for the implementor, and concrete classes that implement the implementor interface. This pattern decouples the abstraction from its implementation, allowing both to vary independently."
	},
	"Decorator": {
		"scope": "python",
		"prefix": "decorator",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Component}(ABC):",
			"    \"\"\"",
			"    Component: Abstract base class for '${1:Component}' objects.",
			"    Define the interface for concrete components.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${2:operation}' method. Needs to be implemented by concrete components.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:ConcreteComponent}(${1:Component}):",
			"    \"\"\"",
			"    ConcreteComponent: Concrete component class that implements the '${1:Component}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:Decorator}(ABC):",
			"    \"\"\"",
			"    Decorator: Abstract base class for decorators.",
			"    Maintains a reference to a '${1:Component}' object and also conforms to the '${1:Component}' interface.",
			"    \"\"\"",
			"    def __init__(self, ${5:component}: ${1:Component}) -> None:",
			"        self.${5:component}: ${1:Component} = ${5:component}",
			"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${2:operation}' method. Needs to be implemented by concrete decorators.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${6:ConcreteDecorator}(${4:Decorator}):",
			"    \"\"\"",
			"    ConcreteDecorator: Concrete decorator class that extends the functionality of the '${1:Component}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        # Additional functionality here",
			"        self.${5:component}.${2:operation}()"
		],
		"description": "Implements the Decorator design pattern in Python. Attaches additional responsibilities to an object dynamically."
	},
	"Proxy": {
		"scope": "python",
		"prefix": "proxy",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Subject}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Subject}' objects.",
			"    Defines the interface for the real object and its proxy.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract method '${2:operation}'. Must be implemented by real subjects and proxies.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:RealSubject}(${1:Subject}):",
			"    \"\"\"",
			"    Real subject class that implements the '${1:Subject}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:Proxy}(${1:Subject}):",
			"    \"\"\"",
			"    Proxy class that implements the '${1:Subject}' interface.",
			"    Maintains a reference to the real subject and controls access to it.",
			"    \"\"\"",
			"    def __init__(self, ${5:real_subject}: ${3:RealSubject}) -> None:",
			"        \"\"\"",
			"        Initialize the Proxy with a reference to the real subject.",
			"        \"\"\"",
			"        self._${5:real_subject}: ${3:RealSubject} = ${5:real_subject}",
			"",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Perform the operation, checking authorization before delegating to the real subject.",
			"        \"\"\"",
			"        if self.${6:is_authorized}():",
			"            self._${5:real_subject}.${2:operation}()",
			"",
			"    def ${6:is_authorized}(self) -> bool:",
			"        \"\"\"",
			"        Check if the user is authorized to access the real subject.",
			"        \"\"\"",
			"        return True"
		],
		"description": "Implements the Proxy design pattern in Python. Provides a surrogate or placeholder for another object to control access to it."
	},
	"Strategy": {
		"scope": "python",
		"prefix": "strategy",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Strategy}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Strategy}' objects.",
			"    Defines the interface for all concrete strategies.",
			"    \"\"\"",
			"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract '${2:operation}' method. Must be implemented by concrete strategies.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:ConcreteStrategyA}(${1:Strategy}):",
			"    \"\"\"",
			"    Concrete strategy class that implements the '${1:Strategy}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${4:ConcreteStrategyB}(${1:Strategy}):",
			"    \"\"\"",
			"    Another concrete strategy class that implements the '${1:Strategy}' interface.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        pass",
			"",
			"class ${5:Context}:",
			"    \"\"\"",
			"    Context class that uses a strategy.",
			"    \"\"\"",
			"    def __init__(self, ${6:strategy}: ${1:Strategy}) -> None:",
			"        self._${6:strategy}: ${1:Strategy} = ${6:strategy}",
			"",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Perform the operation by delegating to the strategy.",
			"        \"\"\"",
			"        self._${6:strategy}.${2:operation}()"
		],
		"description": "Implements the Strategy design pattern in Python. Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Allows the algorithm to vary independently from clients that use it."
	},
	"Template Method": {
		"scope": "python",
		"prefix": "template_method",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:AbstractClass}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:AbstractClass}' objects.",
			"    Defines abstract primitive operations that concrete subclasses define to implement steps of an algorithm.",
			"    Implements a template method defining the algorithm's skeleton.",
			"    \"\"\"",
			"    def ${2:template_method}(self) -> None:",
			"        \"\"\"",
			"        Defines the skeleton of an algorithm.",
			"        \"\"\"",
			"        self.${3:primitive_operation_1}()",
			"        self.${4:primitive_operation_2}()",
			"        self.${5:required_operation_1}()",
			"        self.${6:hook_1}()",
			"        self.${7:required_operation_2}()",
			"        self.${8:hook_2}()",
			"",
			"    @abstractmethod",
			"    def ${5:required_operation_1}(self) -> None:",
			"        \"\"\"",
			"        Abstract operation that must be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${7:required_operation_2}(self) -> None:",
			"        \"\"\"",
			"        Another abstract operation that must be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"    def ${6:hook_1}(self) -> None:",
			"        \"\"\"",
			"        A hook that can be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"    def ${8:hook_2}(self) -> None:",
			"        \"\"\"",
			"        Another hook that can be overridden by subclasses.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${9:ConcreteClass}(${1:AbstractClass}):",
			"    \"\"\"",
			"    Concrete subclass that implements the '${1:AbstractClass}' interface.",
			"    \"\"\"",
			"    def ${5:required_operation_1}(self) -> None:",
			"        pass",
			"",
			"    def ${7:required_operation_2}(self) -> None:",
			"        pass"
		],
		"description": "Implements the Template Method design pattern in Python. Defines the algorithm's skeleton in an operation, allowing subclasses to customize specific steps without changing the overall structure."
	},
	"Observer": {
		"scope": "python",
		"prefix": "observer",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"from typing import List",
			"",
			"class ${1:Subject}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Subject}' objects.",
			"    Maintains a list of observers and notifies them of state changes.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:attach}(self, observer: ${6:Observer}) -> None:",
			"        \"\"\"",
			"        Attach an observer to the subject.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${3:detach}(self, observer: ${6:Observer}) -> None:",
			"        \"\"\"",
			"        Detach an observer from the subject.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${4:notify}(self) -> None:",
			"        \"\"\"",
			"        Notify all observers about an event.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${5:ConcreteSubject}(${1:Subject}):",
			"    \"\"\"",
			"    Concrete subject class that extends the '${1:Subject}' interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self._observers: List[${6:Observer}] = []",
			"",
			"    def ${2:attach}(self, observer: ${6:Observer}) -> None:",
			"        self._observers.append(observer)",
			"",
			"    def ${3:detach}(self, observer: ${6:Observer}) -> None:",
			"        self._observers.remove(observer)",
			"",
			"    def ${4:notify}(self) -> None:",
			"        for observer in self._observers:",
			"            observer.${7:update}(self)",
			"",
			"class ${6:Observer}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${6:Observer}' objects.",
			"    Defines an updating interface for objects that should be notified of changes in a subject.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${7:update}(self, subject: ${1:Subject}) -> None:",
			"        \"\"\"",
			"        Receive update from the subject.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${8:ConcreteObserver}(${6:Observer}):",
			"    \"\"\"",
			"    Concrete observer class that implements the '${6:Observer}' interface.",
			"    \"\"\"",
			"    def ${7:update}(self, subject: ${1:Subject}) -> None:",
			"        pass"
		],
		"description": "Implements the Observer design pattern in Python. Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically."
	},
	"Chain of Responsibility": {
		"scope": "python",
		"prefix": "chain_of_responsibility",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"from enum import Enum",
			"from typing import Any, Optional",
			"",
			"class ${1:RequestType}(Enum):",
			"    \"\"\"",
			"    Enumerates all supported request types.",
			"    \"\"\"",
			"    ${2:TYPE1} = 1",
			"    ${3:TYPE2} = 2",
			"    ${4:TYPE3} = 3",
			"",
			"class ${5:Request}:",
			"    \"\"\"",
			"    Represents a request in the chain of responsibility.",
			"    \"\"\"",
			"    def __init__(self, type: ${1:RequestType}, payload: Any) -> None:",
			"        self.type: ${1:RequestType} = type",
			"        self.payload: Any = payload",
			"",
			"class ${6:Handler}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${6:Handler}' objects.",
			"    Defines an interface for handling requests and implements the successor link.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${7:set_next}(self, handler: ${6:Handler}) -> ${6:Handler}:",
			"        \"\"\"",
			"        Set the next handler in the chain.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        \"\"\"",
			"        Handle the request.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${9:AbstractHandler}(${6:Handler}):",
			"    \"\"\"",
			"    Abstract handler class that implements the '${6:Handler}' interface.",
			"    \"\"\"",
			"    _next_handler: Optional[${6:Handler}] = None",
			"",
			"    def ${7:set_next}(self, handler: ${6:Handler}) -> ${6:Handler}:",
			"        self._next_handler = handler",
			"        return handler",
			"",
			"    @abstractmethod",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        \"\"\"",
			"        Handle the request.",
			"        \"\"\"",
			"        # The default behavior is to forward the request to the next handler.",
			"        if self._next_handler:",
			"            return self._next_handler.${8:handle}(request)",
			"        return None",
			"",
			"class ${10:ConcreteHandler1}(${9:AbstractHandler}):",
			"    \"\"\"",
			"    Concrete handler class that extends the '${9:AbstractHandler}' interface.",
			"    \"\"\"",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        if request.type == ${1:RequestType}.${2:TYPE1}:",
			"            # Handle the request",
			"            return request.payload",
			"        return super().${8:handle}(request)",
			"",
			"class ${11:ConcreteHandler2}(${9:AbstractHandler}):",
			"    \"\"\"",
			"    Another concrete handler class that extends the '${9:AbstractHandler}' interface.",
			"    \"\"\"",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        if request.type == ${1:RequestType}.${3:TYPE2}:",
			"            # Handle the request",
			"            return request.payload",
			"        return super().${8:handle}(request)",
			"",
			"class ${12:ConcreteHandler3}(${9:AbstractHandler}):",
			"    \"\"\"",
			"    Yet another concrete handler class that extends the '${9:AbstractHandler}' interface.",
			"    \"\"\"",
			"    def ${8:handle}(self, request: ${5:Request}) -> Any:",
			"        if request.type == ${1:RequestType}.${4:TYPE3}:",
			"            # Handle the request",
			"            return request.payload",
			"        return super().${8:handle}(request)",
			""
		],
		"description": "Implements the Chain of Responsibility design pattern in Python. Avoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chains the receiving objects and passes the request along the chain until an object handles it."
	},
	"Memento": {
		"scope": "python",
		"prefix": "memento",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"from typing import Any, List",
			"",
			"class ${1:Originator}:",
			"    \"\"\"",
			"    Originator class that creates a memento containing a snapshot of its current internal state.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self._state: Any = None",
			"",
			"    def ${2:save}(self) -> Memento:",
			"        \"\"\"",
			"        Save the current state inside a memento.",
			"        \"\"\"",
			"        return Memento(self._state)",
			"",
			"    def ${3:restore}(self, memento: Memento) -> None:",
			"        \"\"\"",
			"        Restore the internal state from a memento.",
			"        \"\"\"",
			"        self._state = memento.${5:get_state}()",
			"",
			"class ${4:Memento}(ABC):",
			"    \"\"\"",
			"    Abstract Memento class that stores the internal state of the originator.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${5:get_state}(self) -> Any:",
			"        \"\"\"",
			"        Abstract method that must be implemented by concrete mementos.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${6:ConcreteMemento}(${4:Memento}):",
			"    \"\"\"",
			"    Concrete memento class that extends the '${4:Memento}' interface.",
			"    \"\"\"",
			"    def __init__(self, state: Any) -> None:",
			"        self._state: Any = state",
			"",
			"    def ${5:get_state}(self) -> Any:",
			"        return self._state",
			"",
			"class ${7:Caretaker}:",
			"    \"\"\"",
			"    Caretaker class that keeps track of multiple mementos.",
			"    \"\"\"",
			"    def __init__(self, originator: ${1:Originator}) -> None:",
			"        self._originator: ${1:Originator} = originator",
			"        self._mementos: List[Memento] = []",
			"",
			"    def ${8:backup}(self) -> None:",
			"        \"\"\"",
			"        Save the current state of the originator inside a memento.",
			"        \"\"\"",
			"        self._mementos.append(self._originator.${2:save}())",
			"",
			"    def ${9:undo}(self) -> None:",
			"        \"\"\"",
			"        Restore the originator's state from the last memento in the list.",
			"        \"\"\"",
			"        if not self._mementos:",
			"            return",
			"        memento = self._mementos.pop()",
			"        self._originator.${3:restore}(memento)"
		],
		"description": "Implements the Memento design pattern in Python. Captures and externalizes an object's internal state so that it can be restored to this state later, without violating encapsulation."
	},
	"State": {
		"scope": "python",
		"prefix": "state",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Context}:",
			"  \"\"\"",
			"  Context class that maintains an instance of a ConcreteState subclass defining the current state.",
			"  \"\"\"",
			"  def __init__(self, state: ${2:State}) -> None:",
			"    # Initialize the '${1:Context}' object with the initial state.",
			"    self._state: ${2:State} = state",
			"",
			"  def ${3:request}(self) -> None:",
			"    # Delegate the request to the current state.",
			"    self._state.${4:handle}(self)",
			"",
			"  def ${5:change_state}(self, state: ${2:State}) -> None:",
			"    # Change the current state.",
			"    self._state = state",
			"",
			"class ${2:State}(ABC):",
			"  \"\"\"",
			"  Abstract base class for '${2:State}' objects.",
			"  Defines an interface for encapsulating the behavior associated with a particular state of the '${1:Context}' object.",
			"  \"\"\"",
			"  @abstractmethod",
			"  def ${4:handle}(self, context: ${1:Context}) -> None:",
			"    \"\"\"",
			"    Abstract method that must be implemented by concrete states.",
			"    \"\"\"",
			"    pass",
			"",
			"class ${3:ConcreteStateA}(${2:State}):",
			"  \"\"\"",
			"  Concrete state class that extends the '${2:State}' interface.",
			"  \"\"\"",
			"  def ${4:handle}(self, context: ${1:Context}) -> None:",
			"    # Handle the request and change the state of the context.",
			"    pass",
			"",
			"class ${5:ConcreteStateB}(${2:State}):",
			"  \"\"\"",
			"  Another concrete state class that extends the '${2:State}' interface.",
			"  \"\"\"",
			"  def ${4:handle}(self, context: ${1:Context}) -> None:",
			"    # Handle the request and change the state of the context.",
			"    pass"
		],
		"description": "Implements the State design pattern in Python. Allows an object to alter its behavior when its internal state changes. The object will appear to change its class."
	},
	"Visitor": {
		"scope": "python",
		"prefix": "visitor",
		"body": [
			"from abc import ABC, abstractmethod",
			"",
			"class ${1:Visitor}(ABC):",
			"    \"\"\"",
			"    Abstract base class for visitors.",
			"    Declares a set of visit methods, one for each element type in the object structure.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def visit_${2:element_type_1}(self, element: ${2:ElementType1}) -> None:",
			"        \"\"\"",
			"        Visit method for ${2:ElementType1}.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def visit_${3:element_type_2}(self, element: ${3:ElementType2}) -> None:",
			"        \"\"\"",
			"        Visit method for ${3:ElementType2}.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${4:Element}(ABC):",
			"    \"\"\"",
			"    Abstract base class for elements in the object structure.",
			"    Declares an `accept` method that accepts a visitor.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def accept(self, visitor: ${1:Visitor}) -> None:",
			"        \"\"\"",
			"        Accept method for visitors.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${2:ElementType1}(${4:Element}):",
			"    \"\"\"",
			"    Concrete element class that extends the '${4:Element}' interface.",
			"    \"\"\"",
			"    def accept(self, visitor: ${1:Visitor}) -> None:",
			"        visitor.visit_${2:element_type_1}(self)",
			"",
			"class ${3:ElementType2}(${4:Element}):",
			"    \"\"\"",
			"    Another concrete element class that extends the '${4:Element}' interface.",
			"    \"\"\"",
			"    def accept(self, visitor: ${1:Visitor}) -> None:",
			"        visitor.visit_${3:element_type_2}(self)"
		],
		"description": "Implements the Visitor design pattern in Python. Allows defining new operations without changing the classes of the elements on which they operate."
	},
	"Composite": {
		"scope": "python",
		"prefix": "composite",
		"body": [
			"from abc import ABC, abstractmethod",
			"from typing import List",
			"",
			"class ${1:Component}(ABC):",
			"    \"\"\"",
			"    Abstract base class for components.",
			"    Declares the interface for objects in the composition.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract method representing the '${2:operation}' to be performed.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${3:Leaf}(${1:Component}):",
			"    \"\"\"",
			"    Leaf class that represents individual objects in the composition.",
			"    \"\"\"",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Implement '${2:operation}' for the leaf.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${4:Composite}(${1:Component}):",
			"    \"\"\"",
			"    Composite class that contains '${3:Leaf}' and '${4:Composite}' components.",
			"    Implements the operations declared by the Component interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self._children: List[${1:Component}] = []",
			"",
			"    def add(self, component: ${1:Component}) -> None:",
			"        \"\"\"",
			"        Add a component to the composite.",
			"        \"\"\"",
			"        self._children.append(component)",
			"",
			"    def remove(self, component: ${1:Component}) -> None:",
			"        \"\"\"",
			"        Remove a component from the composite.",
			"        \"\"\"",
			"        self._children.remove(component)",
			"",
			"    def ${2:operation}(self) -> None:",
			"        \"\"\"",
			"        Implement '${2:operation}' for the composite.",
			"        \"\"\"",
			"        for child in self._children:",
			"            child.${2:operation}()"
		],
		"description": "Implements the Composite design pattern in Python. Composes objects into tree structures to represent part-whole hierarchies. Clients can treat individual objects and compositions of objects uniformly."
	},
	"Iterator": {
		"prefix": "iterator",
		"body": [
			"from collections.abc import Iterable, Iterator",
			"from typing import Any, List",
			"",
			"class ${1:ConcreteIterator}(${2:Iterator}):",
			"    \"\"\"",
			"    Concrete iterator class that implements the Iterator interface.",
			"    \"\"\"",
			"    def __init__(self, collection: ${3:Iterable}) -> None:",
			"        \"\"\"",
			"        Initialize the iterator with the given collection.",
			"        \"\"\"",
			"        self._collection: ${3:Iterable} = collection",
			"        self._position: int = 0",
			"",
			"    def __iter__(self) -> ${2:Iterator}:",
			"        \"\"\"",
			"        Return the iterator object.",
			"        \"\"\"",
			"        return self",
			"",
			"    def __next__(self) -> ${4:Any}:",
			"        \"\"\"",
			"        Return the next element from the collection.",
			"        \"\"\"",
			"        try:",
			"            value = self._collection[self._position]",
			"            self._position += 1",
			"            return value",
			"        except IndexError:",
			"            raise StopIteration",
			"",
			"class ${5:ConcreteIterable}(${3:Iterable}):",
			"    \"\"\"",
			"    Concrete iterable class that implements the Iterable interface.",
			"    \"\"\"",
			"    def __init__(self, collection: List[${4:Any}]) -> None:",
			"        \"\"\"",
			"        Initialize the iterable with the given list.",
			"        \"\"\"",
			"        self._collection: List[${4:Any}] = collection",
			"",
			"    def __iter__(self) -> ${1:ConcreteIterator}:",
			"        \"\"\"",
			"        Return the iterator object for the iterable.",
			"        \"\"\"",
			"        return ${1:ConcreteIterator}(self._collection)"
		],
		"description": "Implements the Iterator design pattern in Python. Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation."
	},
	"Mediator": {
		"scope": "python",
		"prefix": "mediator",
		"body": [
			"from abc import ABC, abstractmethod",
			"from typing import Any, List",
			"",
			"class ${1:Mediator}(ABC):",
			"    \"\"\"",
			"    Mediator interface that defines the communication protocol between colleagues.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:register_colleague}(self, colleague: ${6:Colleague}) -> None:",
			"        \"\"\"",
			"        Register a colleague with the mediator.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${3:send}(self, sender: ${6:Colleague}, event: Any) -> None:",
			"        \"\"\"",
			"        Send an event from a colleague to other colleagues through the mediator.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${6:Colleague}(ABC):",
			"    \"\"\"",
			"    Colleague class that communicates through a mediator.",
			"    \"\"\"",
			"    def __init__(self, mediator: ${1:Mediator}) -> None:",
			"        \"\"\"",
			"        Initialize the colleague with a reference to the mediator.",
			"        \"\"\"",
			"        self._mediator: ${1:Mediator} = mediator",
			"",
			"    @abstractmethod",
			"    def ${3:send}(self, event: Any) -> None:",
			"        \"\"\"",
			"        Send an event to other colleagues through the mediator.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${7:receive}(self, event: Any) -> None:",
			"        \"\"\"",
			"        Handle an incoming event from the mediator.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${8:ConcreteMediator}(${1:Mediator}):",
			"    \"\"\"",
			"    Concrete mediator class that implements the Mediator interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        \"\"\"",
			"        Initialize the concrete mediator.",
			"        \"\"\"",
			"        self._colleagues: List[${6:Colleague}] = []",
			"",
			"    def ${2:register_colleague}(self, colleague: ${6:Colleague}) -> None:",
			"        \"\"\"",
			"        Register a colleague with the mediator.",
			"        \"\"\"",
			"        self._colleagues.append(colleague)",
			"",
			"    def ${3:send}(self, sender: ${6:Colleague}, event: Any) -> None:",
			"        \"\"\"",
			"        Broadcast an event from a sender to other colleagues.",
			"        \"\"\"",
			"        for colleague in self._colleagues:",
			"            if colleague != sender:",
			"                colleague.${7:receive}(event)",
			"",
			"class ${8:ConcreteColleague}(${6:Colleague}):",
			"    \"\"\"",
			"    Concrete colleague class that implements the Colleague interface.",
			"    \"\"\"",
			"    def ${7:receive}(self, event: Any) -> None:",
			"        \"\"\"",
			"        Handle an incoming event from the mediator.",
			"        \"\"\"",
			"        pass"
		],
		"description": "Implements the Mediator design pattern in Python. Defines an object that centralizes communication between a set of objects, allowing them to communicate without being directly connected."
	}
}
