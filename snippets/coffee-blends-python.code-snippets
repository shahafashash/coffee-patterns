{
    "Factory-Singleton Blend": {
        "scope": "python",
        "prefix": "!blend_factory_singleton",
        "body": [
            "from __future__ import annotations",
            "from abc import ABC, abstractmethod",
			"from typing import Any, Dict",
			"",
			"class ${1:SingletonMeta}(type):",
			"    \"\"\"",
			"    Metaclass implementing the Singleton design pattern.",
			"    \"\"\"",
			"    _instances: Dict[${1:SingletonMeta}, Any] = {}",
			"",
			"    def __call__(cls, *args, **kwargs):",
			"        \"\"\"",
			"        Override the default behavior of creating instances.",
			"        Ensures that only one instance of the class exists.",
			"        \"\"\"",
			"        if cls not in cls._instances:",
			"            cls._instances[cls] = super().__call__(*args, **kwargs)",
			"        return cls._instances[cls]",
            "",
            "class ${2:Product}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${2:Product}' objects.",
			"    It declares the interface for the type of objects that the factory method creates.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${3:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract ${3:operation} method. Needs to be implemented by concrete '${2:Product}' objects.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${4:ConcreteProductA}(${2:Product}):",
			"    \"\"\"",
			"    Concrete product class that implements the '${2:Product}' interface.",
			"    \"\"\"",
			"    def ${3:operation}(self) -> None:",
			"        pass",
			"",
			"class ${5:ConcreteProductB}(${2:Product}):",
			"    \"\"\"",
			"    Another concrete product class that implements the '${2:Product}' interface.",
			"    \"\"\"",
			"    def ${3:operation}(self) -> None:",
			"        pass",
			"",
			"class ${6:Creator}(ABC, metaclass=${1:SingletonMeta}):",
			"    \"\"\"",
			"    Abstract base class for '${6:Creator}' objects.",
			"    It declares the factory method that is supposed to return an object of type '${2:Product}'.",
            "    The ${1:SingletonMeta} metaclass ensures that only one instance of each creator class exists.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${7:factory_method}(self) -> ${2:Product}:",
			"        \"\"\"",
			"        Abstract ${7:factory_method} method. Needs to be implemented by concrete '${6:Creator}' objects.",
			"        ",
			"        Returns:",
			"            ${2:Product}: An object of type '${2:Product}'.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${8:ConcreteCreatorA}(${6:Creator}):",
			"    \"\"\"",
			"    Concrete creator class that implements the '${6:Creator}' interface.",
			"    It overrides the factory method to create a '${4:ConcreteProductA}' instance.",
			"    \"\"\"",
			"    def ${7:factory_method}(self) -> ${4:ConcreteProductA}:",
			"        \"\"\"",
			"        Overrides the factory method to create a '${4:ConcreteProductA}' instance.",
			"        ",
			"        Returns:",
			"            ${4:ConcreteProductA}: An object of type '${4:ConcreteProductA}'.",
			"        \"\"\"",
			"        return ${4:ConcreteProductA}()",
			"",
			"class ${9:ConcreteCreatorB}(${6:Creator}):",
			"    \"\"\"",
			"    Another concrete creator class that implements the '${6:Creator}' interface.",
			"    It overrides the factory method to create a '${5:ConcreteProductB}' instance.",
			"    \"\"\"",
			"    def ${7:factory_method}(self) -> ${5:ConcreteProductB}:",
			"        \"\"\"",
			"        Overrides the factory method to create a '${5:ConcreteProductB}' instance.",
			"        ",
			"        Returns:",
			"            ${5:ConcreteProductB}: An object of type '${5:ConcreteProductB}'.",
			"        \"\"\"",
			"        return ${5:ConcreteProductB}()",
			""
        ],
        "description": "Combine Factory Method and Singleton patterns.\nThe Creator class is a Singleton, ensuring a single point of control for the creation process.\nConcrete creators extend Creator to produce different types of Products.\nEach call to the factory method creates a new instance of the respective Product, allowing flexibility in managing multiple instances of products while maintaining a globally controlled creation process."
    },
	{
		"Composite-Visitor Blend": {
			"scope": "python",
			"prefix": "!blend_composite_visitor",
			"body": [
				"from abc import ABC, abstractmethod",
				"from typing import List",
				"",
				"# Element",
				"class ${1:Element}(ABC):",
				"    \"\"\"",
				"    Abstract base class for elements in the object structure.",
				"    Declares the interface for objects in the composition.",
				"    \"\"\"",
				"    @abstractmethod",
				"    def ${2:operation}(self) -> None:",
				"        \"\"\"",
				"        Abstract method representing the '${2:operation}' to be performed.",
				"        \"\"\"",
				"        pass",
				"",
				"    @abstractmethod",
				"    def accept(self, visitor: ${5:Visitor}) -> None:",
				"        \"\"\"",
				"        Accept method for visitors.",
				"        \"\"\"",
				"        pass",
				"",
				"# Leaf",
				"class ${3:Leaf}(${1:Element}):",
				"    \"\"\"",
				"    Leaf class that represents individual objects in the composition.",
				"    \"\"\"",
				"    def ${2:operation}(self) -> None:",
				"        \"\"\"",
				"        Implement '${2:operation}' for the leaf.",
				"        \"\"\"",
				"        pass",
				"",
				"# Composite",
				"class ${4:Composite}(${1:Element}):",
				"    \"\"\"",
				"    Composite class that contains '${3:Leaf}' and '${4:Composite}' components.",
				"    Implements the operations declared by the Element interface.",
				"    \"\"\"",
				"    def __init__(self) -> None:",
				"        self._children: List[${1:Element}] = []",
				"",
				"    def add(self, element: ${1:Element}) -> None:",
				"        \"\"\"",
				"        Add an element to the composite.",
				"        \"\"\"",
				"        self._children.append(element)",
				"",
				"    def remove(self, element: ${1:Element}) -> None:",
				"        \"\"\"",
				"        Remove an element from the composite.",
				"        \"\"\"",
				"        self._children.remove(element)",
				"",
				"    def ${2:operation}(self) -> None:",
				"        \"\"\"",
				"        Implement '${2:operation}' for the composite.",
				"        \"\"\"",
				"        for child in self._children:",
				"            child.${2:operation}()",
				"",
				"# Visitor",
				"class ${5:Visitor}(ABC):",
				"    \"\"\"",
				"    Abstract base class for visitors.",
				"    Declares a set of visit methods, one for each element type in the object structure.",
				"    \"\"\"",
				"    @abstractmethod",
				"    def visit_${6:element_type_1}(self, element: ${6:ElementType1}) -> None:",
				"        \"\"\"",
				"        Visit method for ${6:ElementType1}.",
				"        \"\"\"",
				"        pass",
				"",
				"    @abstractmethod",
				"    def visit_${7:element_type_2}(self, element: ${7:ElementType2}) -> None:",
				"        \"\"\"",
				"        Visit method for ${7:ElementType2}.",
				"        \"\"\"",
				"        pass",
				"",
				"# Concrete Element",
				"class ${6:ElementType1}(${1:Element}):",
				"    \"\"\"",
				"    Concrete element class that extends the '${1:Element}' interface.",
				"    \"\"\"",
				"    def accept(self, visitor: ${5:Visitor}) -> None:",
				"        visitor.visit_${6:element_type_1}(self)",
				"",
				"# Another Concrete Element",
				"class ${7:ElementType2}(${1:Element}):",
				"    \"\"\"",
				"    Another concrete element class that extends the '${1:Element}' interface.",
				"    \"\"\"",
				"    def accept(self, visitor: ${5:Visitor}) -> None:",
				"        visitor.visit_${7:element_type_2}(self)",
				"",
				"# Concrete Visitor",
				"class ${8:ConcreteVisitor}(${5:Visitor}):",
				"    \"\"\"",
				"    Concrete visitor class that provides concrete implementations for visit methods.",
				"    \"\"\"",
				"    def visit_${6:element_type_1}(self, element: ${6:ElementType1}) -> None:",
				"        \"\"\"",
				"        Override the visit method for ${6:ElementType1}.",
				"        \"\"\"",
				"        pass",
				"",
				"    def visit_${7:element_type_2}(self, element: ${7:ElementType2}) -> None:",
				"        \"\"\"",
				"        Override the visit method for ${7:ElementType2}.",
				"        \"\"\"",
				"        pass"
			],
			"description": "Combine Composite and Visitor patterns.\nThe Composite pattern allows clients to treat individual objects and compositions of objects uniformly.\nThe Visitor pattern allows clients to perform operations on objects without having to modify their class hierarchy.\nThe Visitor pattern also allows operations to be performed on objects of different types in a structured and extensible way."
		}
	},
	"Proxy-Observer Blend": {
		"scope": "python",
		"prefix": "!blend_proxy_observer",
		"body": [
			"from __future__ import annotations",
			"from abc import ABC, abstractmethod",
			"from typing import List",
			"",
			"class ${1:Subject}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${1:Subject}' objects.",
			"    Maintains a list of observers and notifies them of state changes.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${2:attach}(self, observer: ${7:Observer}) -> None:",
			"        \"\"\"",
			"        Attach an observer to the subject.",
			"",
			"        Args:",
			"            observer (Observer): An observer to attach to the subject.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${3:detach}(self, observer: ${7:Observer}) -> None:",
			"        \"\"\"",
			"        Detach an observer from the subject.",
			"",
			"        Args:",
			"            observer (Observer): An observer to detach from the subject.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${4:notify}(self) -> None:",
			"        \"\"\"",
			"        Notify all observers about an event.",
			"        \"\"\"",
			"        pass",
			"",
			"    @abstractmethod",
			"    def ${5:operation}(self) -> None:",
			"        \"\"\"",
			"        Abstract method '${5:operation}'. Must be implemented by real subjects and proxies.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${6:RealSubject}(${1:Subject}):",
			"    \"\"\"",
			"    Concrete subject class that extends the '${1:Subject}' interface.",
			"    \"\"\"",
			"    def __init__(self) -> None:",
			"        self._observers: List[${7:Observer}] = []",
			"",
			"    def ${2:attach}(self, observer: ${7:Observer}) -> None:",
			"        self._observers.append(observer)",
			"",
			"    def ${3:detach}(self, observer: ${7:Observer}) -> None:",
			"        self._observers.remove(observer)",
			"",
			"    def ${4:notify}(self) -> None:",
			"        for observer in self._observers:",
			"            observer.${8:update}(self)",
			"",
			"    def ${5:operation}(self) -> None:",
			"        pass",
			"",
			"class ${7:Observer}(ABC):",
			"    \"\"\"",
			"    Abstract base class for '${7:Observer}' objects.",
			"    Defines an updating interface for objects that should be notified of changes in a subject.",
			"    \"\"\"",
			"    @abstractmethod",
			"    def ${8:update}(self, subject: ${1:Subject}) -> None:",
			"        \"\"\"",
			"        Receive update from the subject.",
			"",
			"        Args:",
			"            subject (Subject): The subject that notified the observer.",
			"        \"\"\"",
			"        pass",
			"",
			"class ${9:ConcreteObserver}(${7:Observer}):",
			"    \"\"\"",
			"    Concrete observer class that implements the '${7:Observer}' interface.",
			"    \"\"\"",
			"    def ${8:update}(self, subject: ${1:Subject}) -> None:",
			"    \"\"\"",
			"    Override the observer's update method to define custom behavior.",
			"",
			"    Args:",
			"        subject (Subject): The subject that notified the observer.",
			"    \"\"\"",
			"        pass",
			"",
			"class ${10:Proxy}(${1:Subject}):",
			"    \"\"\"",
			"    Proxy class that extends the '${1:Subject}' interface.",
			"    Maintains a reference to the real subject and forwards requests to it.",
			"    \"\"\"",
			"    def __init__(self, ${11:real_subject}: ${6:RealSubject}) -> None:",
			"        self._${11:real_subject}: ${6:RealSubject} = ${11:real_subject}",
			"",
			"    def ${2:attach}(self, observer: ${7:Observer}) -> None:",
			"        if self._${12:is_authorized}():",
			"            self._${11:real_subject}.${2:attach}(observer)",
			"",
			"    def ${3:detach}(self, observer: ${7:Observer}) -> None:",
			"        if self._${12:is_authorized}():",
			"            self._${11:real_subject}.${3:detach}(observer)",
			"",
			"    def ${4:notify}(self) -> None:",
			"        self._${11:real_subject}.${4:notify}()",
			"",
			"    def ${5:operation}(self) -> None:",
			"        if self._${12:is_authorized}():",
			"            self._${11:real_subject}.${5:operation}()",
			"",
		],
		"description": "Combine Proxy and Observer patterns.\nThe Proxy pattern provides a surrogate or placeholder for another object to control access to it.\nThe Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically."
	}
}